<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>clemcore.clemgame API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>clemcore.clemgame</code></h1>
</header>
<section id="section-intro">
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="clemcore.clemgame.benchmark" href="benchmark.html">clemcore.clemgame.benchmark</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="clemcore.clemgame.instances" href="instances.html">clemcore.clemgame.instances</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="clemcore.clemgame.master" href="master.html">clemcore.clemgame.master</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="clemcore.clemgame.metrics" href="metrics.html">clemcore.clemgame.metrics</a></code></dt>
<dd>
<div class="desc"><p>Definition of metrics/scores that should be defined and logged for all games.
This constants should be used so that the naming is standardised across …</p></div>
</dd>
<dt><code class="name"><a title="clemcore.clemgame.player" href="player.html">clemcore.clemgame.player</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="clemcore.clemgame.recorder" href="recorder.html">clemcore.clemgame.recorder</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="clemcore.clemgame.registry" href="registry.html">clemcore.clemgame.registry</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="clemcore.clemgame.resources" href="resources.html">clemcore.clemgame.resources</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="clemcore.clemgame.transcripts" href="transcripts/index.html">clemcore.clemgame.transcripts</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="clemcore.clemgame.DefaultGameRecorder"><code class="flex name class">
<span>class <span class="ident">DefaultGameRecorder</span></span>
<span>(</span><span>game_name: str, experiment_name: str, game_id: int, dialogue_pair: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DefaultGameRecorder(GameRecorder):
    &#34;&#34;&#34;Default game recorder with common methods for recording game episodes.&#34;&#34;&#34;
    def __init__(self, game_name: str, experiment_name: str, game_id: int, dialogue_pair: str):
        self._game_name = game_name
        self._log_current_turn = 0
        &#34;&#34;&#34; Stores players and turn during the runs &#34;&#34;&#34;
        self.interactions = {
            &#34;meta&#34;: dict(experiment_name=experiment_name, game_id=game_id, dialogue_pair=dialogue_pair),
            &#34;players&#34;: {},
            &#34;turns&#34;: [[]]  # already prepared to log the first round of turns
        }
        &#34;&#34;&#34; Stores calls to the API &#34;&#34;&#34;
        self.requests = []

    def log_next_round(self):
        &#34;&#34;&#34;Call this method to group interactions per turn.&#34;&#34;&#34;
        self._log_current_turn += 1
        self.interactions[&#34;turns&#34;].append([])

    def log_key(self, key: str, value: Any):
        &#34;&#34;&#34;Add a key and value to the internal log.
        Args:
            key: A string to identify the kind of log entry to be made.
            value: The content of the entry to be logged.
        &#34;&#34;&#34;
        self.interactions[key] = value
        module_logger.info(f&#34;{self._game_name}: Logged a game-specific interaction key: {key}.&#34;)

    def log_players(self, players_dic: Dict):
        &#34;&#34;&#34;Log/record the players in this game episode.
        Args:
            players_dic: Dictionary of players in this game episode.
        &#34;&#34;&#34;
        self.interactions[&#34;players&#34;] = players_dic
        module_logger.info(f&#34;{self._game_name}: Logged players metadata.&#34;)

    def log_event(self, from_: str, to: str, action: Dict, call: Tuple[Any, Any] = None):
        &#34;&#34;&#34;Add an event to the internal log.
        It can be only an action or an action plus an API call that should have the same timestamp as the action.
        Args:
            from_: The identifier string of the Player/GM that originated the action.
            to: The identifier string of the Player/GM target of the action.
            action: The benchmark action to be logged.
            call: If given, this is a tuple whose first element is the input prompt object (after API-specific
                manipulation) as passed to the API and the second element is the raw response object as returned by the
                API.
        &#34;&#34;&#34;
        timestamp = datetime.now().isoformat()
        action_obj = {
            &#34;from&#34;: from_,
            &#34;to&#34;: to,
            &#34;timestamp&#34;: timestamp,
            &#34;action&#34;: action
        }
        self.interactions[&#34;turns&#34;][self._log_current_turn].append(copy.deepcopy(action_obj))
        module_logger.info(
            f&#34;{self._game_name}: Logged {action[&#39;type&#39;]} action ({from_}-&gt;{to}).&#34;)
        if call:
            call_obj = {
                &#34;timestamp&#34;: timestamp,
                &#34;manipulated_prompt_obj&#34;: self._needs_copy(call[0]),
                &#34;raw_response_obj&#34;: self._needs_copy(call[1])
            }
            self.requests.append(call_obj)
            module_logger.info(f&#34;{self._game_name}: Logged a call with timestamp {timestamp}&#34;)

    @staticmethod
    def _needs_copy(call_obj):
        &#34;&#34;&#34;Deepcopy objects that may otherwise lead to reference issues.
        Args:
            call_obj: The object to be deep-copied for safety.
        Returns:
            The deep-copy of the passed object, or the original object if it is safe to use.
        &#34;&#34;&#34;
        if isinstance(call_obj, Dict) or isinstance(call_obj, List):
            return copy.deepcopy(call_obj)
        elif isinstance(call_obj, str):
            return call_obj[:]
        return call_obj

    def store_records(self, results_root: str, dialogue_pair_desc: str, game_record_dir: str):
        &#34;&#34;&#34;Store benchmark records.
        Raise warnings if a mandatory element is empty or format is wrong.
        Args:
            results_root: The root path to the results directory.
            dialogue_pair_desc: A string combining the Player pair names to be used as directory name.
            game_record_dir: The game&#39;s record directory path.
        &#34;&#34;&#34;
        if not self.interactions[&#34;players&#34;]:
            module_logger.warning(f&#34;Players metadada is missing!&#34;)
        else:
            for name in self.interactions[&#34;players&#34;]:
                &#34;&#34;&#34;The transcript builder relies on specific player identifiers.&#34;&#34;&#34;
                try:
                    assert name == &#34;GM&#34; or name.startswith(&#34;Player &#34;)
                except AssertionError:
                    module_logger.warning(f&#34;Invalid player identifiers, html builder won&#39;t work.&#34;)
        if not self.interactions[&#34;turns&#34;]:
            module_logger.warning(f&#34;Interaction logs are missing!&#34;)
        if not self.requests:
            module_logger.warning(f&#34;No calls logged!&#34;)
        store_results_file(self._game_name, self.interactions,
                           &#34;interactions.json&#34;,
                           dialogue_pair_desc,
                           sub_dir=game_record_dir,
                           results_dir=results_root)
        store_results_file(self._game_name, self.requests,
                           &#34;requests.json&#34;,
                           dialogue_pair_desc,
                           sub_dir=game_record_dir,
                           results_dir=results_root)</code></pre>
</details>
<div class="desc"><p>Default game recorder with common methods for recording game episodes.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="clemcore.clemgame.recorder.GameRecorder" href="recorder.html#clemcore.clemgame.recorder.GameRecorder">GameRecorder</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="clemcore.clemgame.DefaultGameRecorder.interactions"><code class="name">var <span class="ident">interactions</span></code></dt>
<dd>
<div class="desc"><p>Stores calls to the API</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="clemcore.clemgame.recorder.GameRecorder" href="recorder.html#clemcore.clemgame.recorder.GameRecorder">GameRecorder</a></b></code>:
<ul class="hlist">
<li><code><a title="clemcore.clemgame.recorder.GameRecorder.log_event" href="recorder.html#clemcore.clemgame.recorder.GameRecorder.log_event">log_event</a></code></li>
<li><code><a title="clemcore.clemgame.recorder.GameRecorder.log_key" href="recorder.html#clemcore.clemgame.recorder.GameRecorder.log_key">log_key</a></code></li>
<li><code><a title="clemcore.clemgame.recorder.GameRecorder.log_next_round" href="recorder.html#clemcore.clemgame.recorder.GameRecorder.log_next_round">log_next_round</a></code></li>
<li><code><a title="clemcore.clemgame.recorder.GameRecorder.log_players" href="recorder.html#clemcore.clemgame.recorder.GameRecorder.log_players">log_players</a></code></li>
<li><code><a title="clemcore.clemgame.recorder.GameRecorder.store_records" href="recorder.html#clemcore.clemgame.recorder.GameRecorder.store_records">store_records</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="clemcore.clemgame.DialogueGameMaster"><code class="flex name class">
<span>class <span class="ident">DialogueGameMaster</span></span>
<span>(</span><span>name: str,<br>path: str,<br>experiment: dict,<br>player_models: List[<a title="clemcore.backends.model_registry.Model" href="../backends/model_registry.html#clemcore.backends.model_registry.Model">Model</a>])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DialogueGameMaster(GameMaster):
    &#34;&#34;&#34;Extended GameMaster, implementing turns as described in the clembench paper.
    Has most logging and gameplay procedures implemented, including convenient logging methods.
    &#34;&#34;&#34;
    def __init__(self, name: str, path: str, experiment: dict, player_models: List[backends.Model]):
        &#34;&#34;&#34;
        Args:
            name: The name of the game (as specified in game_registry).
            path: Path to the game (as specified in game_registry).
            experiment: The experiment (set of instances) to use.
            player_models: Player models to use for one or two players.
        &#34;&#34;&#34;
        super().__init__(name, path, experiment, player_models)
        # the logging works with an internal mapping of &#34;Player N&#34; -&gt; Player
        self.players_by_names: Dict[str, Player] = collections.OrderedDict()
        self.context_for_player: Dict[str, Dict] = dict()  # context entries look like {&#34;role&#34;:&#34;user&#34;, &#34;content&#34;: ...}
        self.current_round: int = 0
        self.current_player: Player = None
        self.current_player_idx: int = 0
        self.info = {}

    def __setstate__(self, state):
        self.__dict__.update(state)
        for player in self.players_by_names.values():  # sync game recorders (not copied in Player)
            player.game_recorder = self.game_recorder

    def get_players(self) -&gt; List[Player]:
        &#34;&#34;&#34;Get a list of the players.
        Returns:
            List of Player instances in the order they are added.
        &#34;&#34;&#34;
        return list(self.players_by_names.values())

    def add_player(self, player: Player, initial_prompt: Union[str, Dict] = None,
                   initial_context: Union[str, Dict] = None):
        &#34;&#34;&#34;Add a Player (sub-)class object to the game. The same Player (sub-)class object cannot be added twice.
        The player identity is determined by the player&#39;s name.

        Important: During gameplay, the players will be called in the same order as added to the game master!

        Args:
            player: The player to be added to the game. The player&#39;s name must be unique.
            initial_prompt: The initial prompt given to the player (optional). See Player for more details.
            initial_context: A context to be immediately set for the player (optional). This is useful for initial
                            prompts that are supposed to be handled as the first context, for example, when adding
                            the other player&#39;s response to the prompt is not necessary, but the player is supposed
                            to directly react to the initial prompt. Alternatively, overwrite on_before_game() and
                            use set_context_for(player) to set the player context.
        &#34;&#34;&#34;
        player.game_recorder = self.game_recorder  # player should record to the same interaction log
        player.initial_prompt = initial_prompt
        player.name = f&#34;Player {len(self.players_by_names) + 1} ({player.__class__.__name__})&#34;
        if player.name in self.players_by_names:
            raise ValueError(f&#34;Player names must be unique, &#34;
                             f&#34;but there is already a player registered with name &#39;{player.name}&#39;.&#34;)
        self.players_by_names[player.name] = player
        if initial_context is not None:
            assert isinstance(initial_context, (str, dict)), \
                f&#34;The initial context must be a str or dict, but is {type(initial_context)}&#34;
            if isinstance(initial_context, dict):
                assert &#34;content&#34; in initial_context, &#34;The initial context requires a content entry&#34;
                extras = {k: v for k, v in initial_context.items() if k not in [&#34;role&#34;, &#34;content&#34;]}
                self.set_context_for(player, initial_context[&#34;content&#34;], **extras)
            else:
                self.set_context_for(player, initial_context)

    def setup(self, **kwargs):
        &#34;&#34;&#34;Load resources and prepare everything to play the game.
        Needs to log the players dictionary via self.log_players(players_dict).
        Intended to be left as-is by inheriting classes. Implement game-specific setup functionality in the _on_setup
        method.
        Called by the game&#39;s GameBenchmark run method for each game instance.
        Args:
            kwargs: Keyword arguments used to set up the GameMaster instance. This is usually a game instance object
                read from the game&#39;s instances.json.
        &#34;&#34;&#34;
        self._on_setup(**kwargs)
        # log players
        players_descriptions = collections.OrderedDict(GM=f&#34;Game master for {self.game_name}&#34;)
        for name, player in self.players_by_names.items():
            players_descriptions[name] = player.get_description()
        self.log_players(players_descriptions)
        self.current_player = self.get_players()[self.current_player_idx]
        # call game hooks
        self._on_before_game()
        self._on_before_round()

    @abc.abstractmethod
    def _on_setup(self, **kwargs):
        &#34;&#34;&#34;Method executed at the start of the default setup method.
        Template method: Must be implemented!
        Use add_player() here to add the players.
        Args:
            kwargs: Keyword arguments of the game instance. This is usually a game instance object
                read from the game&#39;s instances.json.
        &#34;&#34;&#34;
        pass

    def get_game_state(self):
        &#34;&#34;&#34;For future use.&#34;&#34;&#34;
        return None

    def get_current_player(self) -&gt; Player:
        &#34;&#34;&#34;Get the current player.
        Returns:
            The current player Player object.
        &#34;&#34;&#34;
        return self.current_player

    def set_context_for(self, player: Player, content: str, **extras):
        &#34;&#34;&#34;Set the context for the specified Player.
        The player will be prompted with the context on its next turn.
        The context always has a &#39;role&#39; and &#39;content&#39; entry where the &#39;role&#39; is always set to &#39;user&#39;.
        Args:
            player: The player to set the context for.
            content: The text content to be added to the context.
            extras: Additional content to be merged into the context e.g. information about images.
        &#34;&#34;&#34;
        if player is None:
            return
        message = {&#34;role&#34;: &#34;user&#34;, &#34;content&#34;: content}
        context = {**extras, **message}
        self.context_for_player[player.name] = context

    def get_context_for(self, player) -&gt; Dict:
        &#34;&#34;&#34;Get the current context of a player.
        Args:
            player: The player&#39;s name.
        Returns:
            The player&#39;s context, a dict.
        &#34;&#34;&#34;
        assert player is not None, &#34;Cannot get player context for &#39;None&#39;&#34;
        assert player.name in self.context_for_player, f&#34;No context set for {player.name}&#34;
        context = self.context_for_player[player.name]
        assert &#34;role&#34; in context, f&#34;Player context must have a &#39;role&#39; entry&#34;
        assert context[&#34;role&#34;] == &#34;user&#34;, f&#34;Role of player context must be &#39;user&#39;&#34;
        assert &#34;content&#34; in context, f&#34;Player context must have a &#39;content&#39; entry&#34;
        return context

    def play(self) -&gt; None:
        &#34;&#34;&#34;Main play loop method.
        This method is called to run the game for benchmarking.
        &#34;&#34;&#34;
        done = False
        while not done:
            # get the current context message for the current player, set by set_context_for():
            context = self.get_context_for(self.current_player)
            # generate/get response from the player based on their message history and the passed context message:
            response = self.current_player(context)
            # pass the player response to the step() method for processing and determining if play continues:
            done, _ = self.step(response)

    def step(self, response: str) -&gt; Tuple[bool, Dict]:
        &#34;&#34;&#34;Transitions the game state by applying the current player&#39;s response.
        Args:
            response: The response (verbal action) of the current player.
        Returns:
            Tuple of: done, info
        &#34;&#34;&#34;
        # compute scores first, so that we are sure that the player&#39;s context
        # can still be retrieved (state has not changed yet)
        context = self.get_context_for(self.current_player)
        self.info[&#34;response_score&#34;] = self.compute_response_score(response, context)
        self.info[&#34;response_feedback&#34;] = self.get_response_feedback(response, context)
        self.info[&#34;episode_score&#34;] = 0

        # todo: it seems we should change the order here: Parse should come first, and then validate.
        # JJ: It should also probably be done before the method calls above...
        # While parse might throw a parsing (format error) validate would check solely for satisfied game rules.
        # Note: this would allow to cut off too long responses (during parse) and to only validate on the cut off piece.
        if self._validate_player_response(self.current_player, response):
            parsed_response = self._parse_response(self.current_player, response)
            self._on_valid_player_response(self.current_player, parsed_response)

        if self._should_pass_turn():
            self.current_player = self._next_player()
            if self._start_next_round():
                self._on_after_round()
                self.current_round += 1

        done = not self._does_game_proceed()
        if done:
            self._on_after_game()
            self.info[&#34;episode_score&#34;] = self.compute_episode_score()
        elif self._start_next_round():
            self.__prepare_next_round()

        info = deepcopy(self.info)
        self.info = {}  # reset info after each step
        return done, info

    def _next_player(self) -&gt; Player:
        &#34;&#34;&#34;
        Subclasses can overwrite this method to determine the next player after a player&#39;s turn has been passed.

        Default: The game master passes the turn to the next player in the player list (order as added).
        Starting again with the first player, when all players have had their turn(s).

        Returns:
            The next (current) player.
        &#34;&#34;&#34;
        self.current_player_idx = (self.current_player_idx + 1) % len(self.players_by_names)
        return self.get_players()[self.current_player_idx]

    def _start_next_round(self) -&gt; bool:
        &#34;&#34;&#34;
        Subclasses can overwrite this method to specify when a next round should start after a player&#39;s turn is passed.

        Default: Start next round when we cycled through the whole list i.e. it is again the first player&#39;s turn.

        Returns:
            True, when to start a new round
        &#34;&#34;&#34;
        return self.current_player_idx == 0

    def __prepare_next_round(self):
        self.log_next_round()  # add record entry for player turns
        self._on_before_round()

    def get_response_feedback(self, response: str, context: Dict):
        &#34;&#34;&#34;Create text feedback to a player response.
        Optional.
        Args:
            response: The response of the current player.
            context: The context given to the current player to generate the response for.
        Returns:
            A verbal feedback about the player&#39;s response given the context.
        &#34;&#34;&#34;
        return None

    def compute_response_score(self, response: str, context: Dict):
        &#34;&#34;&#34;Calculate a score for a player response.
        Mandatory.
        Args:
            response: The response of the current player.
            context: The context given to the current player to generate the response for.
        Returns:
            The performance score for a player&#39;s response given the context.
        &#34;&#34;&#34;
        return 0

    def compute_episode_score(self):
        &#34;&#34;&#34;Calculate a score for the entire episode.
        Mandatory.
        Returns:
            The performance of the agent over the whole episode.
        &#34;&#34;&#34;
        return 0

    def _should_pass_turn(self):
        &#34;&#34;&#34;Determine if a player is done for the current turn.
        Whether to pass the turn to the next player. Otherwise, the current player keeps playing
        based on the context set via set_player_context(player, content).
        &#34;&#34;&#34;
        return True

    @abc.abstractmethod
    def _on_valid_player_response(self, player: Player, parsed_response: str):
        &#34;&#34;&#34;
        Method executed after a player response has been parsed and validated.

        Set the response as the context for the other player (if necessary).

        You could also set a new context for the current player and give the player
        another turn by letting _should_pass_turn() return False.

        To do this use the method set_context_for(player, response).
        Args:
            player: The Player instance that produced the response (or has been modified by the GM).
            parsed_response: The parsed and valid response of the current player.
        &#34;&#34;&#34;
        pass

    @abc.abstractmethod
    def _validate_player_response(self, player: Player, response: str) -&gt; bool:
        &#34;&#34;&#34;
        Decide if a player response is valid. An invalid response breaks the game rules and might end the game.

        Note: If the response is not valid, then _parse_response() and on_valid_player_response() will not be called.

        However, game developers can decide to give the player another turn by letting _should_pass_turn() return False.

        Args:
            player: The player that gave the response.
            response: The response of the current player.
        Returns:
            True, if the response is fine. Otherwise, False.
        &#34;&#34;&#34;
        pass

    def _parse_response(self, player: Player, response: str) -&gt; str:
        &#34;&#34;&#34;Decide if a response utterance should be modified and apply modifications.

        Hook: Modify this method for game-specific functionality.

        Args:
            player: The Player instance that produced the response. Intended to allow for individual handling of
                different players.
            response: The response of the current player.
        Returns:
            The parsed response
        &#34;&#34;&#34;
        return response

    @abc.abstractmethod
    def _does_game_proceed(self) -&gt; bool:
        &#34;&#34;&#34;Check if game should proceed.

        Template method: Must be implemented!

        This method is used to determine if a game should continue or be stopped. Both successful completion of the game
        and game-ending failures should lead to this method returning False.
        Returns:
            A bool, True if game continues, False if game should stop.
        &#34;&#34;&#34;
        pass

    def _on_before_round(self):
        &#34;&#34;&#34;Executed in the play loop before a new round of gameplay starts.

        Hook: Modify this method for game-specific functionality.
        &#34;&#34;&#34;
        pass

    def _on_after_round(self):
        &#34;&#34;&#34;Executed in the play loop after a round of gameplay finishes i.e. _start_next_round() resolves to True.

        Hook: Modify this method for game-specific functionality.
        &#34;&#34;&#34;
        pass

    def _on_before_game(self):
        &#34;&#34;&#34;Executed once at the start, before entering the play loop.

        Hook: Modify this method for game-specific functionality.

        Adding the initial prompt to the dialogue history with this method is recommended.
        &#34;&#34;&#34;
        pass

    def _on_after_game(self):
        &#34;&#34;&#34;Executed once at the end, after exiting the play loop.

        Hook: Modify this method for game-specific functionality.

        This method is useful to process and log/record overall game results.
        &#34;&#34;&#34;
        pass</code></pre>
</details>
<div class="desc"><p>Extended GameMaster, implementing turns as described in the clembench paper.
Has most logging and gameplay procedures implemented, including convenient logging methods.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>The name of the game (as specified in game_registry).</dd>
<dt><strong><code>path</code></strong></dt>
<dd>Path to the game (as specified in game_registry).</dd>
<dt><strong><code>experiment</code></strong></dt>
<dd>The experiment (set of instances) to use.</dd>
<dt><strong><code>player_models</code></strong></dt>
<dd>Player models to use for one or two players.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="clemcore.clemgame.master.GameMaster" href="master.html#clemcore.clemgame.master.GameMaster">GameMaster</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="clemcore.clemgame.DialogueGameMaster.add_player"><code class="name flex">
<span>def <span class="ident">add_player</span></span>(<span>self,<br>player: <a title="clemcore.clemgame.player.Player" href="player.html#clemcore.clemgame.player.Player">Player</a>,<br>initial_prompt: str | Dict = None,<br>initial_context: str | Dict = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_player(self, player: Player, initial_prompt: Union[str, Dict] = None,
               initial_context: Union[str, Dict] = None):
    &#34;&#34;&#34;Add a Player (sub-)class object to the game. The same Player (sub-)class object cannot be added twice.
    The player identity is determined by the player&#39;s name.

    Important: During gameplay, the players will be called in the same order as added to the game master!

    Args:
        player: The player to be added to the game. The player&#39;s name must be unique.
        initial_prompt: The initial prompt given to the player (optional). See Player for more details.
        initial_context: A context to be immediately set for the player (optional). This is useful for initial
                        prompts that are supposed to be handled as the first context, for example, when adding
                        the other player&#39;s response to the prompt is not necessary, but the player is supposed
                        to directly react to the initial prompt. Alternatively, overwrite on_before_game() and
                        use set_context_for(player) to set the player context.
    &#34;&#34;&#34;
    player.game_recorder = self.game_recorder  # player should record to the same interaction log
    player.initial_prompt = initial_prompt
    player.name = f&#34;Player {len(self.players_by_names) + 1} ({player.__class__.__name__})&#34;
    if player.name in self.players_by_names:
        raise ValueError(f&#34;Player names must be unique, &#34;
                         f&#34;but there is already a player registered with name &#39;{player.name}&#39;.&#34;)
    self.players_by_names[player.name] = player
    if initial_context is not None:
        assert isinstance(initial_context, (str, dict)), \
            f&#34;The initial context must be a str or dict, but is {type(initial_context)}&#34;
        if isinstance(initial_context, dict):
            assert &#34;content&#34; in initial_context, &#34;The initial context requires a content entry&#34;
            extras = {k: v for k, v in initial_context.items() if k not in [&#34;role&#34;, &#34;content&#34;]}
            self.set_context_for(player, initial_context[&#34;content&#34;], **extras)
        else:
            self.set_context_for(player, initial_context)</code></pre>
</details>
<div class="desc"><p>Add a Player (sub-)class object to the game. The same Player (sub-)class object cannot be added twice.
The player identity is determined by the player's name.</p>
<p>Important: During gameplay, the players will be called in the same order as added to the game master!</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>player</code></strong></dt>
<dd>The player to be added to the game. The player's name must be unique.</dd>
<dt><strong><code>initial_prompt</code></strong></dt>
<dd>The initial prompt given to the player (optional). See Player for more details.</dd>
<dt><strong><code>initial_context</code></strong></dt>
<dd>A context to be immediately set for the player (optional). This is useful for initial
prompts that are supposed to be handled as the first context, for example, when adding
the other player's response to the prompt is not necessary, but the player is supposed
to directly react to the initial prompt. Alternatively, overwrite on_before_game() and
use set_context_for(player) to set the player context.</dd>
</dl></div>
</dd>
<dt id="clemcore.clemgame.DialogueGameMaster.compute_episode_score"><code class="name flex">
<span>def <span class="ident">compute_episode_score</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_episode_score(self):
    &#34;&#34;&#34;Calculate a score for the entire episode.
    Mandatory.
    Returns:
        The performance of the agent over the whole episode.
    &#34;&#34;&#34;
    return 0</code></pre>
</details>
<div class="desc"><p>Calculate a score for the entire episode.
Mandatory.</p>
<h2 id="returns">Returns</h2>
<p>The performance of the agent over the whole episode.</p></div>
</dd>
<dt id="clemcore.clemgame.DialogueGameMaster.compute_response_score"><code class="name flex">
<span>def <span class="ident">compute_response_score</span></span>(<span>self, response: str, context: Dict)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_response_score(self, response: str, context: Dict):
    &#34;&#34;&#34;Calculate a score for a player response.
    Mandatory.
    Args:
        response: The response of the current player.
        context: The context given to the current player to generate the response for.
    Returns:
        The performance score for a player&#39;s response given the context.
    &#34;&#34;&#34;
    return 0</code></pre>
</details>
<div class="desc"><p>Calculate a score for a player response.
Mandatory.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>response</code></strong></dt>
<dd>The response of the current player.</dd>
<dt><strong><code>context</code></strong></dt>
<dd>The context given to the current player to generate the response for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The performance score for a player's response given the context.</p></div>
</dd>
<dt id="clemcore.clemgame.DialogueGameMaster.get_context_for"><code class="name flex">
<span>def <span class="ident">get_context_for</span></span>(<span>self, player) ‑> Dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_context_for(self, player) -&gt; Dict:
    &#34;&#34;&#34;Get the current context of a player.
    Args:
        player: The player&#39;s name.
    Returns:
        The player&#39;s context, a dict.
    &#34;&#34;&#34;
    assert player is not None, &#34;Cannot get player context for &#39;None&#39;&#34;
    assert player.name in self.context_for_player, f&#34;No context set for {player.name}&#34;
    context = self.context_for_player[player.name]
    assert &#34;role&#34; in context, f&#34;Player context must have a &#39;role&#39; entry&#34;
    assert context[&#34;role&#34;] == &#34;user&#34;, f&#34;Role of player context must be &#39;user&#39;&#34;
    assert &#34;content&#34; in context, f&#34;Player context must have a &#39;content&#39; entry&#34;
    return context</code></pre>
</details>
<div class="desc"><p>Get the current context of a player.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>player</code></strong></dt>
<dd>The player's name.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The player's context, a dict.</p></div>
</dd>
<dt id="clemcore.clemgame.DialogueGameMaster.get_current_player"><code class="name flex">
<span>def <span class="ident">get_current_player</span></span>(<span>self) ‑> <a title="clemcore.clemgame.player.Player" href="player.html#clemcore.clemgame.player.Player">Player</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_current_player(self) -&gt; Player:
    &#34;&#34;&#34;Get the current player.
    Returns:
        The current player Player object.
    &#34;&#34;&#34;
    return self.current_player</code></pre>
</details>
<div class="desc"><p>Get the current player.</p>
<h2 id="returns">Returns</h2>
<p>The current player Player object.</p></div>
</dd>
<dt id="clemcore.clemgame.DialogueGameMaster.get_game_state"><code class="name flex">
<span>def <span class="ident">get_game_state</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_game_state(self):
    &#34;&#34;&#34;For future use.&#34;&#34;&#34;
    return None</code></pre>
</details>
<div class="desc"><p>For future use.</p></div>
</dd>
<dt id="clemcore.clemgame.DialogueGameMaster.get_players"><code class="name flex">
<span>def <span class="ident">get_players</span></span>(<span>self) ‑> List[<a title="clemcore.clemgame.player.Player" href="player.html#clemcore.clemgame.player.Player">Player</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_players(self) -&gt; List[Player]:
    &#34;&#34;&#34;Get a list of the players.
    Returns:
        List of Player instances in the order they are added.
    &#34;&#34;&#34;
    return list(self.players_by_names.values())</code></pre>
</details>
<div class="desc"><p>Get a list of the players.</p>
<h2 id="returns">Returns</h2>
<p>List of Player instances in the order they are added.</p></div>
</dd>
<dt id="clemcore.clemgame.DialogueGameMaster.get_response_feedback"><code class="name flex">
<span>def <span class="ident">get_response_feedback</span></span>(<span>self, response: str, context: Dict)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_response_feedback(self, response: str, context: Dict):
    &#34;&#34;&#34;Create text feedback to a player response.
    Optional.
    Args:
        response: The response of the current player.
        context: The context given to the current player to generate the response for.
    Returns:
        A verbal feedback about the player&#39;s response given the context.
    &#34;&#34;&#34;
    return None</code></pre>
</details>
<div class="desc"><p>Create text feedback to a player response.
Optional.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>response</code></strong></dt>
<dd>The response of the current player.</dd>
<dt><strong><code>context</code></strong></dt>
<dd>The context given to the current player to generate the response for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A verbal feedback about the player's response given the context.</p></div>
</dd>
<dt id="clemcore.clemgame.DialogueGameMaster.play"><code class="name flex">
<span>def <span class="ident">play</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def play(self) -&gt; None:
    &#34;&#34;&#34;Main play loop method.
    This method is called to run the game for benchmarking.
    &#34;&#34;&#34;
    done = False
    while not done:
        # get the current context message for the current player, set by set_context_for():
        context = self.get_context_for(self.current_player)
        # generate/get response from the player based on their message history and the passed context message:
        response = self.current_player(context)
        # pass the player response to the step() method for processing and determining if play continues:
        done, _ = self.step(response)</code></pre>
</details>
<div class="desc"><p>Main play loop method.
This method is called to run the game for benchmarking.</p></div>
</dd>
<dt id="clemcore.clemgame.DialogueGameMaster.set_context_for"><code class="name flex">
<span>def <span class="ident">set_context_for</span></span>(<span>self,<br>player: <a title="clemcore.clemgame.player.Player" href="player.html#clemcore.clemgame.player.Player">Player</a>,<br>content: str,<br>**extras)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_context_for(self, player: Player, content: str, **extras):
    &#34;&#34;&#34;Set the context for the specified Player.
    The player will be prompted with the context on its next turn.
    The context always has a &#39;role&#39; and &#39;content&#39; entry where the &#39;role&#39; is always set to &#39;user&#39;.
    Args:
        player: The player to set the context for.
        content: The text content to be added to the context.
        extras: Additional content to be merged into the context e.g. information about images.
    &#34;&#34;&#34;
    if player is None:
        return
    message = {&#34;role&#34;: &#34;user&#34;, &#34;content&#34;: content}
    context = {**extras, **message}
    self.context_for_player[player.name] = context</code></pre>
</details>
<div class="desc"><p>Set the context for the specified Player.
The player will be prompted with the context on its next turn.
The context always has a 'role' and 'content' entry where the 'role' is always set to 'user'.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>player</code></strong></dt>
<dd>The player to set the context for.</dd>
<dt><strong><code>content</code></strong></dt>
<dd>The text content to be added to the context.</dd>
<dt><strong><code>extras</code></strong></dt>
<dd>Additional content to be merged into the context e.g. information about images.</dd>
</dl></div>
</dd>
<dt id="clemcore.clemgame.DialogueGameMaster.setup"><code class="name flex">
<span>def <span class="ident">setup</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup(self, **kwargs):
    &#34;&#34;&#34;Load resources and prepare everything to play the game.
    Needs to log the players dictionary via self.log_players(players_dict).
    Intended to be left as-is by inheriting classes. Implement game-specific setup functionality in the _on_setup
    method.
    Called by the game&#39;s GameBenchmark run method for each game instance.
    Args:
        kwargs: Keyword arguments used to set up the GameMaster instance. This is usually a game instance object
            read from the game&#39;s instances.json.
    &#34;&#34;&#34;
    self._on_setup(**kwargs)
    # log players
    players_descriptions = collections.OrderedDict(GM=f&#34;Game master for {self.game_name}&#34;)
    for name, player in self.players_by_names.items():
        players_descriptions[name] = player.get_description()
    self.log_players(players_descriptions)
    self.current_player = self.get_players()[self.current_player_idx]
    # call game hooks
    self._on_before_game()
    self._on_before_round()</code></pre>
</details>
<div class="desc"><p>Load resources and prepare everything to play the game.
Needs to log the players dictionary via self.log_players(players_dict).
Intended to be left as-is by inheriting classes. Implement game-specific setup functionality in the _on_setup
method.
Called by the game's GameBenchmark run method for each game instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Keyword arguments used to set up the GameMaster instance. This is usually a game instance object
read from the game's instances.json.</dd>
</dl></div>
</dd>
<dt id="clemcore.clemgame.DialogueGameMaster.step"><code class="name flex">
<span>def <span class="ident">step</span></span>(<span>self, response: str) ‑> Tuple[bool, Dict]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step(self, response: str) -&gt; Tuple[bool, Dict]:
    &#34;&#34;&#34;Transitions the game state by applying the current player&#39;s response.
    Args:
        response: The response (verbal action) of the current player.
    Returns:
        Tuple of: done, info
    &#34;&#34;&#34;
    # compute scores first, so that we are sure that the player&#39;s context
    # can still be retrieved (state has not changed yet)
    context = self.get_context_for(self.current_player)
    self.info[&#34;response_score&#34;] = self.compute_response_score(response, context)
    self.info[&#34;response_feedback&#34;] = self.get_response_feedback(response, context)
    self.info[&#34;episode_score&#34;] = 0

    # todo: it seems we should change the order here: Parse should come first, and then validate.
    # JJ: It should also probably be done before the method calls above...
    # While parse might throw a parsing (format error) validate would check solely for satisfied game rules.
    # Note: this would allow to cut off too long responses (during parse) and to only validate on the cut off piece.
    if self._validate_player_response(self.current_player, response):
        parsed_response = self._parse_response(self.current_player, response)
        self._on_valid_player_response(self.current_player, parsed_response)

    if self._should_pass_turn():
        self.current_player = self._next_player()
        if self._start_next_round():
            self._on_after_round()
            self.current_round += 1

    done = not self._does_game_proceed()
    if done:
        self._on_after_game()
        self.info[&#34;episode_score&#34;] = self.compute_episode_score()
    elif self._start_next_round():
        self.__prepare_next_round()

    info = deepcopy(self.info)
    self.info = {}  # reset info after each step
    return done, info</code></pre>
</details>
<div class="desc"><p>Transitions the game state by applying the current player's response.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>response</code></strong></dt>
<dd>The response (verbal action) of the current player.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple of</code></dt>
<dd>done, info</dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="clemcore.clemgame.master.GameMaster" href="master.html#clemcore.clemgame.master.GameMaster">GameMaster</a></b></code>:
<ul class="hlist">
<li><code><a title="clemcore.clemgame.master.GameMaster.log_to_self" href="master.html#clemcore.clemgame.master.GameMaster.log_to_self">log_to_self</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="clemcore.clemgame.GameBenchmark"><code class="flex name class">
<span>class <span class="ident">GameBenchmark</span></span>
<span>(</span><span>game_spec: <a title="clemcore.clemgame.registry.GameSpec" href="registry.html#clemcore.clemgame.registry.GameSpec">GameSpec</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GameBenchmark(GameResourceLocator):
    &#34;&#34;&#34;Organizes the run of a particular collection of game instances which compose a benchmark for the game.
    Supports different experiment conditions for games.
    &#34;&#34;&#34;

    def __init__(self, game_spec: GameSpec):
        &#34;&#34;&#34;
        Args:
            game_spec: The name of the game (as specified in game_registry)
        &#34;&#34;&#34;
        super().__init__(game_spec[&#34;game_name&#34;], game_spec[&#34;game_path&#34;])
        self.game_spec = game_spec
        self.instances = None
        self.filter_experiment: List[str] = []
        self.is_single_player = True if game_spec[&#34;players&#34;] == &#34;one&#34; else False

    def setup(self, instances_name: str = None):
        &#34;&#34;&#34;Set up a benchmark run of a clemgame.
        Args:
            instances_name: Name of the instances JSON file to be used for the benchmark run.
        &#34;&#34;&#34;
        if instances_name:
            self.instances = self.load_instances(instances_name)
        elif hasattr(self.game_spec, &#39;instances&#39;):
            self.instances = self.load_instances(self.game_spec.instances)
        else:
            self.instances = self.load_instances(&#34;instances&#34;)  # fallback to instances.json default

    def create_game_instance_iterator(self, shuffle_instances: bool = False):
        &#34;&#34;&#34;Create a GameInstanceIterator object for running a game.
        Args:
            shuffle_instances: If True, instances are randomly shuffled.
        Returns:
            A GameInstanceIterator object.
        &#34;&#34;&#34;
        return GameInstanceIterator(self.instances, do_shuffle=shuffle_instances)

    def compute_scores(self, results_dir: str):
        &#34;&#34;&#34;Compute and store scores for each episode and player pair.
        Episode score JSON files are stored in each corresponding episode directory. Combined scores for a player/model
        pair are stored in the player pair directory.
        Args:
            results_dir: Path to the results directory.
        &#34;&#34;&#34;
        results_root = results_dir
        dialogue_partners = [model_dir for model_dir in os.listdir(results_root)
                             if os.path.isdir(os.path.join(results_root, model_dir))]
        for dialogue_pair in dialogue_partners:
            game_result_path = os.path.join(results_root, dialogue_pair, self.game_name)
            if not os.path.exists(game_result_path) or not os.path.isdir(game_result_path):
                stdout_logger.info(&#34;No results directory found at: &#34; + game_result_path)
                continue

            experiment_dirs = [experiment_dir for experiment_dir in os.listdir(game_result_path)
                               if os.path.isdir(os.path.join(game_result_path, experiment_dir))]
            if not experiment_dirs:
                stdout_logger.warning(f&#34;{self.game_name}: No experiments for {dialogue_pair}&#34;)
            for experiment_dir in experiment_dirs:
                experiment_path = os.path.join(game_result_path, experiment_dir)
                experiment_name = &#34;_&#34;.join(experiment_dir.split(&#34;_&#34;)[1:])  # remove leading index number
                if self.filter_experiment and experiment_name not in self.filter_experiment:
                    stdout_logger.info(f&#34;Skip experiment {experiment_name}&#34;)
                    continue
                stdout_logger.info(f&#34;Scoring: {experiment_name}&#34;)
                experiment_config = self.load_results_json(f&#34;{experiment_dir}/experiment_{experiment_name}&#34;,
                                                           results_root, dialogue_pair)
                episode_dirs = [file for file in os.listdir(experiment_path)
                                if os.path.isdir(os.path.join(experiment_path, file))]
                error_count = 0
                for episode_dir in tqdm(episode_dirs, desc=&#34;Scoring episodes&#34;):
                    try:
                        rel_episode_path = f&#34;{experiment_dir}/{episode_dir}&#34;
                        game_instance = self.load_results_json(f&#34;{rel_episode_path}/instance&#34;,
                                                               results_root, dialogue_pair)
                        game_interactions = self.load_results_json(f&#34;{rel_episode_path}/interactions&#34;,
                                                                   results_root, dialogue_pair)

                        game_scorer = self.create_game_scorer(experiment_config, game_instance)
                        game_scorer.compute_scores(game_interactions)
                        game_scorer.store_scores(results_root, dialogue_pair, rel_episode_path)
                    except Exception:  # continue with other episodes if something goes wrong
                        module_logger.exception(f&#34;{self.game_name}: Cannot score {episode_dir} (but continue)&#34;)
                        error_count += 1
                if error_count &gt; 0:
                    stdout_logger.error(
                        f&#34;{self.game_name}: &#39;{error_count}&#39; exceptions occurred: See clembench.log for details.&#34;)

    def run(self, player_models: List[backends.Model], results_dir: str):
        &#34;&#34;&#34;Runs game-play on all game instances for a game.
        There must be an instances.json with the following structure:
        &#34;experiments&#34;: [ # this is required
            {
                &#34;name&#34;: &lt;experiment-name&gt;, # this is required
                &#34;param1&#34;: &#34;value1&#34;, # optional
                &#34;param2&#34;: &#34;value2&#34;, # optional
                &#34;game_instances&#34;: [ # this is required
                    {&#34;game_id&#34;: &lt;value&gt;, &#34;initial_prompt&#34;: ... },
                    {&#34;game_id&#34;: &lt;value&gt;, &#34;initial_prompt&#34;: ... }
                ]
            }
        ]

        The instances will be automatically stored in &#34;game-name&#34; with the following structure:
            - results
                - pairing
                    - game-name
                        - experiment_name
                            - experiment.json
                            - episode_id
                                - instance.json
                                - interaction.json

        Args:
            player_models: A list of backends.Model instances to run the game with.
            results_dir: Path to the results directory.
        &#34;&#34;&#34;
        results_root = results_dir
        experiments: List = self.instances[&#34;experiments&#34;]
        if not experiments:
            module_logger.warning(f&#34;{self.game_name}: No experiments for %s&#34;, self.game_name)
        total_experiments = len(experiments)
        for experiment_idx, experiment in enumerate(experiments):
            experiment_name = experiment[&#39;name&#39;]
            if self.filter_experiment and experiment_name not in self.filter_experiment:
                stdout_logger.info(f&#34;Skip experiment {experiment_idx + 1} of {total_experiments}: {experiment_name}&#34;)
                continue
            stdout_logger.info(f&#34;Run experiment {experiment_idx + 1} of {total_experiments}: {experiment_name}&#34;)
            # Determine dialogue partners: How often to run the experiment with different partners
            dialogue_partners: List[List[backends.Model]] = []

            if player_models:  # favor runtime argument over experiment config
                dialogue_partners = [list([m for m in player_models])]  # shallow copy
            elif &#34;dialogue_partners&#34; in experiment:  # edge-case when names are given in experiment config
                for dialogue_pair_names in experiment[&#34;dialogue_partners&#34;]:
                    player_models = []
                    for model_name in dialogue_pair_names:
                        player_model = backends.get_model_for(model_name)
                        player_models.append(player_model)
                    dialogue_partners.append(player_models)
                module_logger.info(f&#34;{self.game_name}: Detected &#39;dialogue_partners&#39; in experiment config. &#34;
                                   f&#34;Will run with: {dialogue_partners}&#34;)

            if not dialogue_partners:
                message = (f&#34;{self.game_name}: Neither &#39;dialogue_partners&#39; set in experiment instance&#34;
                           f&#34; nor &#39;models&#39; given as run arg&#34;)
                stdout_logger.error(message)
                raise ValueError(message)

            for dialogue_pair in dialogue_partners:
                dialogue_pair_desc = self.get_dialogue_pair_descriptor(dialogue_pair)
                episode_counter = 0

                module_logger.info(&#34;Activity: %s Experiment: %s Partners: %s Episode: %d&#34;,
                                   self.game_name, experiment_name, dialogue_pair_desc, episode_counter)

                experiment_record_dir = f&#34;{experiment_idx}_{experiment_name}&#34;
                experiment_config = {k: experiment[k] for k in experiment if k != &#39;game_instances&#39;}

                # Add some important infos to track
                experiment_config[&#34;timestamp&#34;] = datetime.now().isoformat()
                experiment_config[&#34;dialogue_partners&#34;] = dialogue_pair_desc

                store_results_file(self.game_name, experiment_config,
                                   f&#34;experiment_{experiment_name}.json&#34;,
                                   dialogue_pair_desc,
                                   sub_dir=experiment_record_dir,
                                   results_dir=results_root)

                error_count = 0
                time_experiment_start = datetime.now()
                game_instances: List = experiment[&#34;game_instances&#34;]
                for game_instance in tqdm(game_instances, desc=&#34;Playing games&#34;):
                    game_id = game_instance[&#34;game_id&#34;]
                    module_logger.info(&#34;Activity: %s Experiment: %s Episode: %d Game: %s&#34;,
                                       self.game_name, experiment_name, episode_counter, game_id)
                    episode_dir = experiment_record_dir + f&#34;/episode_{episode_counter}&#34;
                    store_results_file(self.game_name, game_instance,
                                       f&#34;instance.json&#34;,
                                       dialogue_pair_desc,
                                       sub_dir=episode_dir,
                                       results_dir=results_root)
                    game_recorder = DefaultGameRecorder(self.game_name,
                                                        experiment_config[&#34;name&#34;],  # meta info for transcribe
                                                        game_instance[&#34;game_id&#34;],  # meta info for transcribe
                                                        dialogue_pair_desc)  # meta info for transcribe
                    try:
                        game_master = self.create_game_master(experiment_config, dialogue_pair)
                        game_master.game_recorder = game_recorder
                        game_master.setup(**game_instance)
                        game_master.play()
                        game_master.store_records(results_root, dialogue_pair_desc, episode_dir)
                    except Exception:  # continue with other episodes if something goes wrong
                        module_logger.exception(f&#34;{self.game_name}: Exception for episode {game_id} (but continue)&#34;)
                        error_count += 1
                    episode_counter += 1
                if error_count &gt; 0:
                    stdout_logger.error(
                        f&#34;{self.game_name}: &#39;{error_count}&#39; exceptions occurred: See clembench.log for details.&#34;)
                # Add experiment duration and overwrite file
                time_experiment_end = datetime.now() - time_experiment_start
                experiment_config[&#34;duration&#34;] = str(time_experiment_end)
                store_results_file(self.game_name, experiment_config,
                                   f&#34;experiment_{experiment_name}.json&#34;,
                                   dialogue_pair_desc,
                                   sub_dir=experiment_record_dir,
                                   results_dir=results_root)

    def get_dialogue_pair_descriptor(self, dialogue_pair: List[backends.Model]):
        if self.is_single_player:
            if len(dialogue_pair) &gt; 1:
                message = f&#34;Too many player for singe-player game &#39;{self.game_name}&#39;: &#39;{len(dialogue_pair)}&#39;&#34;
                stdout_logger.error(message)
                raise ValueError(message)
            model_0 = dialogue_pair[0]
            model_0 = f&#34;{model_0.get_name()}-t{model_0.get_temperature()}&#34;
            # still we store to model--model dir (virtual self-play)
            dialogue_pair_desc = f&#34;{model_0}--{model_0}&#34;
        else:  # 2-players
            if len(dialogue_pair) &gt; 2:
                message = f&#34;Too many player for two-player game &#39;{self.game_name}&#39;: &#39;{len(dialogue_pair)}&#39;&#34;
                stdout_logger.error(message)
                raise ValueError(message)
            if len(dialogue_pair) == 1:
                dialogue_pair.append(dialogue_pair[0])  # model expansion
            model_0 = dialogue_pair[0]
            model_0 = f&#34;{model_0.get_name()}-t{model_0.get_temperature()}&#34;
            model_1 = dialogue_pair[1]
            model_1 = f&#34;{model_1.get_name()}-t{model_1.get_temperature()}&#34;
            dialogue_pair_desc = f&#34;{model_0}--{model_1}&#34;
        return dialogue_pair_desc

    def create_game_master(self, experiment: Dict, player_models: List[backends.Model]) -&gt; GameMaster:
        &#34;&#34;&#34;Create a game-specific GameMaster subclass instance to run the game with.
        Must be implemented!
        Args:
            experiment: The experiment (set of instances) to run.
            player_models: Player models to use for one or two players.
        Returns:
            A game-specific GameMaster subclass instance.
        &#34;&#34;&#34;
        raise NotImplementedError()

    def create_game_scorer(self, experiment: Dict, game_instance: Dict) -&gt; GameScorer:
        &#34;&#34;&#34;Create a game-specific GameScorer subclass instance to score benchmark records with.
        Must be implemented!
        Args:
            experiment: The experiment (set of instances) to score.
            game_instance: The game instance to score.
        Returns:
            A game-specific GameScorer subclass instance.
        &#34;&#34;&#34;
        raise NotImplementedError()</code></pre>
</details>
<div class="desc"><p>Organizes the run of a particular collection of game instances which compose a benchmark for the game.
Supports different experiment conditions for games.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>game_spec</code></strong></dt>
<dd>The name of the game (as specified in game_registry)</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="clemcore.clemgame.resources.GameResourceLocator" href="resources.html#clemcore.clemgame.resources.GameResourceLocator">GameResourceLocator</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="clemcore.clemgame.GameBenchmark.compute_scores"><code class="name flex">
<span>def <span class="ident">compute_scores</span></span>(<span>self, results_dir: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_scores(self, results_dir: str):
    &#34;&#34;&#34;Compute and store scores for each episode and player pair.
    Episode score JSON files are stored in each corresponding episode directory. Combined scores for a player/model
    pair are stored in the player pair directory.
    Args:
        results_dir: Path to the results directory.
    &#34;&#34;&#34;
    results_root = results_dir
    dialogue_partners = [model_dir for model_dir in os.listdir(results_root)
                         if os.path.isdir(os.path.join(results_root, model_dir))]
    for dialogue_pair in dialogue_partners:
        game_result_path = os.path.join(results_root, dialogue_pair, self.game_name)
        if not os.path.exists(game_result_path) or not os.path.isdir(game_result_path):
            stdout_logger.info(&#34;No results directory found at: &#34; + game_result_path)
            continue

        experiment_dirs = [experiment_dir for experiment_dir in os.listdir(game_result_path)
                           if os.path.isdir(os.path.join(game_result_path, experiment_dir))]
        if not experiment_dirs:
            stdout_logger.warning(f&#34;{self.game_name}: No experiments for {dialogue_pair}&#34;)
        for experiment_dir in experiment_dirs:
            experiment_path = os.path.join(game_result_path, experiment_dir)
            experiment_name = &#34;_&#34;.join(experiment_dir.split(&#34;_&#34;)[1:])  # remove leading index number
            if self.filter_experiment and experiment_name not in self.filter_experiment:
                stdout_logger.info(f&#34;Skip experiment {experiment_name}&#34;)
                continue
            stdout_logger.info(f&#34;Scoring: {experiment_name}&#34;)
            experiment_config = self.load_results_json(f&#34;{experiment_dir}/experiment_{experiment_name}&#34;,
                                                       results_root, dialogue_pair)
            episode_dirs = [file for file in os.listdir(experiment_path)
                            if os.path.isdir(os.path.join(experiment_path, file))]
            error_count = 0
            for episode_dir in tqdm(episode_dirs, desc=&#34;Scoring episodes&#34;):
                try:
                    rel_episode_path = f&#34;{experiment_dir}/{episode_dir}&#34;
                    game_instance = self.load_results_json(f&#34;{rel_episode_path}/instance&#34;,
                                                           results_root, dialogue_pair)
                    game_interactions = self.load_results_json(f&#34;{rel_episode_path}/interactions&#34;,
                                                               results_root, dialogue_pair)

                    game_scorer = self.create_game_scorer(experiment_config, game_instance)
                    game_scorer.compute_scores(game_interactions)
                    game_scorer.store_scores(results_root, dialogue_pair, rel_episode_path)
                except Exception:  # continue with other episodes if something goes wrong
                    module_logger.exception(f&#34;{self.game_name}: Cannot score {episode_dir} (but continue)&#34;)
                    error_count += 1
            if error_count &gt; 0:
                stdout_logger.error(
                    f&#34;{self.game_name}: &#39;{error_count}&#39; exceptions occurred: See clembench.log for details.&#34;)</code></pre>
</details>
<div class="desc"><p>Compute and store scores for each episode and player pair.
Episode score JSON files are stored in each corresponding episode directory. Combined scores for a player/model
pair are stored in the player pair directory.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>results_dir</code></strong></dt>
<dd>Path to the results directory.</dd>
</dl></div>
</dd>
<dt id="clemcore.clemgame.GameBenchmark.create_game_instance_iterator"><code class="name flex">
<span>def <span class="ident">create_game_instance_iterator</span></span>(<span>self, shuffle_instances: bool = False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_game_instance_iterator(self, shuffle_instances: bool = False):
    &#34;&#34;&#34;Create a GameInstanceIterator object for running a game.
    Args:
        shuffle_instances: If True, instances are randomly shuffled.
    Returns:
        A GameInstanceIterator object.
    &#34;&#34;&#34;
    return GameInstanceIterator(self.instances, do_shuffle=shuffle_instances)</code></pre>
</details>
<div class="desc"><p>Create a GameInstanceIterator object for running a game.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>shuffle_instances</code></strong></dt>
<dd>If True, instances are randomly shuffled.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A GameInstanceIterator object.</p></div>
</dd>
<dt id="clemcore.clemgame.GameBenchmark.create_game_master"><code class="name flex">
<span>def <span class="ident">create_game_master</span></span>(<span>self,<br>experiment: Dict,<br>player_models: List[<a title="clemcore.backends.model_registry.Model" href="../backends/model_registry.html#clemcore.backends.model_registry.Model">Model</a>]) ‑> <a title="clemcore.clemgame.master.GameMaster" href="master.html#clemcore.clemgame.master.GameMaster">GameMaster</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_game_master(self, experiment: Dict, player_models: List[backends.Model]) -&gt; GameMaster:
    &#34;&#34;&#34;Create a game-specific GameMaster subclass instance to run the game with.
    Must be implemented!
    Args:
        experiment: The experiment (set of instances) to run.
        player_models: Player models to use for one or two players.
    Returns:
        A game-specific GameMaster subclass instance.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
<div class="desc"><p>Create a game-specific GameMaster subclass instance to run the game with.
Must be implemented!</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>experiment</code></strong></dt>
<dd>The experiment (set of instances) to run.</dd>
<dt><strong><code>player_models</code></strong></dt>
<dd>Player models to use for one or two players.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A game-specific GameMaster subclass instance.</p></div>
</dd>
<dt id="clemcore.clemgame.GameBenchmark.create_game_scorer"><code class="name flex">
<span>def <span class="ident">create_game_scorer</span></span>(<span>self, experiment: Dict, game_instance: Dict) ‑> <a title="clemcore.clemgame.metrics.GameScorer" href="metrics.html#clemcore.clemgame.metrics.GameScorer">GameScorer</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_game_scorer(self, experiment: Dict, game_instance: Dict) -&gt; GameScorer:
    &#34;&#34;&#34;Create a game-specific GameScorer subclass instance to score benchmark records with.
    Must be implemented!
    Args:
        experiment: The experiment (set of instances) to score.
        game_instance: The game instance to score.
    Returns:
        A game-specific GameScorer subclass instance.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
<div class="desc"><p>Create a game-specific GameScorer subclass instance to score benchmark records with.
Must be implemented!</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>experiment</code></strong></dt>
<dd>The experiment (set of instances) to score.</dd>
<dt><strong><code>game_instance</code></strong></dt>
<dd>The game instance to score.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A game-specific GameScorer subclass instance.</p></div>
</dd>
<dt id="clemcore.clemgame.GameBenchmark.get_dialogue_pair_descriptor"><code class="name flex">
<span>def <span class="ident">get_dialogue_pair_descriptor</span></span>(<span>self,<br>dialogue_pair: List[<a title="clemcore.backends.model_registry.Model" href="../backends/model_registry.html#clemcore.backends.model_registry.Model">Model</a>])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dialogue_pair_descriptor(self, dialogue_pair: List[backends.Model]):
    if self.is_single_player:
        if len(dialogue_pair) &gt; 1:
            message = f&#34;Too many player for singe-player game &#39;{self.game_name}&#39;: &#39;{len(dialogue_pair)}&#39;&#34;
            stdout_logger.error(message)
            raise ValueError(message)
        model_0 = dialogue_pair[0]
        model_0 = f&#34;{model_0.get_name()}-t{model_0.get_temperature()}&#34;
        # still we store to model--model dir (virtual self-play)
        dialogue_pair_desc = f&#34;{model_0}--{model_0}&#34;
    else:  # 2-players
        if len(dialogue_pair) &gt; 2:
            message = f&#34;Too many player for two-player game &#39;{self.game_name}&#39;: &#39;{len(dialogue_pair)}&#39;&#34;
            stdout_logger.error(message)
            raise ValueError(message)
        if len(dialogue_pair) == 1:
            dialogue_pair.append(dialogue_pair[0])  # model expansion
        model_0 = dialogue_pair[0]
        model_0 = f&#34;{model_0.get_name()}-t{model_0.get_temperature()}&#34;
        model_1 = dialogue_pair[1]
        model_1 = f&#34;{model_1.get_name()}-t{model_1.get_temperature()}&#34;
        dialogue_pair_desc = f&#34;{model_0}--{model_1}&#34;
    return dialogue_pair_desc</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="clemcore.clemgame.GameBenchmark.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self,<br>player_models: List[<a title="clemcore.backends.model_registry.Model" href="../backends/model_registry.html#clemcore.backends.model_registry.Model">Model</a>],<br>results_dir: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self, player_models: List[backends.Model], results_dir: str):
    &#34;&#34;&#34;Runs game-play on all game instances for a game.
    There must be an instances.json with the following structure:
    &#34;experiments&#34;: [ # this is required
        {
            &#34;name&#34;: &lt;experiment-name&gt;, # this is required
            &#34;param1&#34;: &#34;value1&#34;, # optional
            &#34;param2&#34;: &#34;value2&#34;, # optional
            &#34;game_instances&#34;: [ # this is required
                {&#34;game_id&#34;: &lt;value&gt;, &#34;initial_prompt&#34;: ... },
                {&#34;game_id&#34;: &lt;value&gt;, &#34;initial_prompt&#34;: ... }
            ]
        }
    ]

    The instances will be automatically stored in &#34;game-name&#34; with the following structure:
        - results
            - pairing
                - game-name
                    - experiment_name
                        - experiment.json
                        - episode_id
                            - instance.json
                            - interaction.json

    Args:
        player_models: A list of backends.Model instances to run the game with.
        results_dir: Path to the results directory.
    &#34;&#34;&#34;
    results_root = results_dir
    experiments: List = self.instances[&#34;experiments&#34;]
    if not experiments:
        module_logger.warning(f&#34;{self.game_name}: No experiments for %s&#34;, self.game_name)
    total_experiments = len(experiments)
    for experiment_idx, experiment in enumerate(experiments):
        experiment_name = experiment[&#39;name&#39;]
        if self.filter_experiment and experiment_name not in self.filter_experiment:
            stdout_logger.info(f&#34;Skip experiment {experiment_idx + 1} of {total_experiments}: {experiment_name}&#34;)
            continue
        stdout_logger.info(f&#34;Run experiment {experiment_idx + 1} of {total_experiments}: {experiment_name}&#34;)
        # Determine dialogue partners: How often to run the experiment with different partners
        dialogue_partners: List[List[backends.Model]] = []

        if player_models:  # favor runtime argument over experiment config
            dialogue_partners = [list([m for m in player_models])]  # shallow copy
        elif &#34;dialogue_partners&#34; in experiment:  # edge-case when names are given in experiment config
            for dialogue_pair_names in experiment[&#34;dialogue_partners&#34;]:
                player_models = []
                for model_name in dialogue_pair_names:
                    player_model = backends.get_model_for(model_name)
                    player_models.append(player_model)
                dialogue_partners.append(player_models)
            module_logger.info(f&#34;{self.game_name}: Detected &#39;dialogue_partners&#39; in experiment config. &#34;
                               f&#34;Will run with: {dialogue_partners}&#34;)

        if not dialogue_partners:
            message = (f&#34;{self.game_name}: Neither &#39;dialogue_partners&#39; set in experiment instance&#34;
                       f&#34; nor &#39;models&#39; given as run arg&#34;)
            stdout_logger.error(message)
            raise ValueError(message)

        for dialogue_pair in dialogue_partners:
            dialogue_pair_desc = self.get_dialogue_pair_descriptor(dialogue_pair)
            episode_counter = 0

            module_logger.info(&#34;Activity: %s Experiment: %s Partners: %s Episode: %d&#34;,
                               self.game_name, experiment_name, dialogue_pair_desc, episode_counter)

            experiment_record_dir = f&#34;{experiment_idx}_{experiment_name}&#34;
            experiment_config = {k: experiment[k] for k in experiment if k != &#39;game_instances&#39;}

            # Add some important infos to track
            experiment_config[&#34;timestamp&#34;] = datetime.now().isoformat()
            experiment_config[&#34;dialogue_partners&#34;] = dialogue_pair_desc

            store_results_file(self.game_name, experiment_config,
                               f&#34;experiment_{experiment_name}.json&#34;,
                               dialogue_pair_desc,
                               sub_dir=experiment_record_dir,
                               results_dir=results_root)

            error_count = 0
            time_experiment_start = datetime.now()
            game_instances: List = experiment[&#34;game_instances&#34;]
            for game_instance in tqdm(game_instances, desc=&#34;Playing games&#34;):
                game_id = game_instance[&#34;game_id&#34;]
                module_logger.info(&#34;Activity: %s Experiment: %s Episode: %d Game: %s&#34;,
                                   self.game_name, experiment_name, episode_counter, game_id)
                episode_dir = experiment_record_dir + f&#34;/episode_{episode_counter}&#34;
                store_results_file(self.game_name, game_instance,
                                   f&#34;instance.json&#34;,
                                   dialogue_pair_desc,
                                   sub_dir=episode_dir,
                                   results_dir=results_root)
                game_recorder = DefaultGameRecorder(self.game_name,
                                                    experiment_config[&#34;name&#34;],  # meta info for transcribe
                                                    game_instance[&#34;game_id&#34;],  # meta info for transcribe
                                                    dialogue_pair_desc)  # meta info for transcribe
                try:
                    game_master = self.create_game_master(experiment_config, dialogue_pair)
                    game_master.game_recorder = game_recorder
                    game_master.setup(**game_instance)
                    game_master.play()
                    game_master.store_records(results_root, dialogue_pair_desc, episode_dir)
                except Exception:  # continue with other episodes if something goes wrong
                    module_logger.exception(f&#34;{self.game_name}: Exception for episode {game_id} (but continue)&#34;)
                    error_count += 1
                episode_counter += 1
            if error_count &gt; 0:
                stdout_logger.error(
                    f&#34;{self.game_name}: &#39;{error_count}&#39; exceptions occurred: See clembench.log for details.&#34;)
            # Add experiment duration and overwrite file
            time_experiment_end = datetime.now() - time_experiment_start
            experiment_config[&#34;duration&#34;] = str(time_experiment_end)
            store_results_file(self.game_name, experiment_config,
                               f&#34;experiment_{experiment_name}.json&#34;,
                               dialogue_pair_desc,
                               sub_dir=experiment_record_dir,
                               results_dir=results_root)</code></pre>
</details>
<div class="desc"><p>Runs game-play on all game instances for a game.
There must be an instances.json with the following structure:
"experiments": [ # this is required
{
"name": <experiment-name>, # this is required
"param1": "value1", # optional
"param2": "value2", # optional
"game_instances": [ # this is required
{"game_id": <value>, "initial_prompt": &hellip; },
{"game_id": <value>, "initial_prompt": &hellip; }
]
}
]</p>
<p>The instances will be automatically stored in "game-name" with the following structure:
- results
- pairing
- game-name
- experiment_name
- experiment.json
- episode_id
- instance.json
- interaction.json</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>player_models</code></strong></dt>
<dd>A list of backends.Model instances to run the game with.</dd>
<dt><strong><code>results_dir</code></strong></dt>
<dd>Path to the results directory.</dd>
</dl></div>
</dd>
<dt id="clemcore.clemgame.GameBenchmark.setup"><code class="name flex">
<span>def <span class="ident">setup</span></span>(<span>self, instances_name: str = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup(self, instances_name: str = None):
    &#34;&#34;&#34;Set up a benchmark run of a clemgame.
    Args:
        instances_name: Name of the instances JSON file to be used for the benchmark run.
    &#34;&#34;&#34;
    if instances_name:
        self.instances = self.load_instances(instances_name)
    elif hasattr(self.game_spec, &#39;instances&#39;):
        self.instances = self.load_instances(self.game_spec.instances)
    else:
        self.instances = self.load_instances(&#34;instances&#34;)  # fallback to instances.json default</code></pre>
</details>
<div class="desc"><p>Set up a benchmark run of a clemgame.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>instances_name</code></strong></dt>
<dd>Name of the instances JSON file to be used for the benchmark run.</dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="clemcore.clemgame.resources.GameResourceLocator" href="resources.html#clemcore.clemgame.resources.GameResourceLocator">GameResourceLocator</a></b></code>:
<ul class="hlist">
<li><code><a title="clemcore.clemgame.resources.GameResourceLocator.load_csv" href="resources.html#clemcore.clemgame.resources.GameResourceLocator.load_csv">load_csv</a></code></li>
<li><code><a title="clemcore.clemgame.resources.GameResourceLocator.load_file" href="resources.html#clemcore.clemgame.resources.GameResourceLocator.load_file">load_file</a></code></li>
<li><code><a title="clemcore.clemgame.resources.GameResourceLocator.load_instances" href="resources.html#clemcore.clemgame.resources.GameResourceLocator.load_instances">load_instances</a></code></li>
<li><code><a title="clemcore.clemgame.resources.GameResourceLocator.load_json" href="resources.html#clemcore.clemgame.resources.GameResourceLocator.load_json">load_json</a></code></li>
<li><code><a title="clemcore.clemgame.resources.GameResourceLocator.load_results_json" href="resources.html#clemcore.clemgame.resources.GameResourceLocator.load_results_json">load_results_json</a></code></li>
<li><code><a title="clemcore.clemgame.resources.GameResourceLocator.load_template" href="resources.html#clemcore.clemgame.resources.GameResourceLocator.load_template">load_template</a></code></li>
<li><code><a title="clemcore.clemgame.resources.GameResourceLocator.store_file" href="resources.html#clemcore.clemgame.resources.GameResourceLocator.store_file">store_file</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="clemcore.clemgame.GameInstanceGenerator"><code class="flex name class">
<span>class <span class="ident">GameInstanceGenerator</span></span>
<span>(</span><span>path: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GameInstanceGenerator(GameResourceLocator):
    &#34;&#34;&#34;Create all game instances for a game benchmark.
    Results in an instances.json with the following structure:

    &#34;experiments&#34;: [ # this is required
        {
            &#34;name&#34;: &lt;experiment-name&gt;, # this is required
            &#34;param1&#34;: &#34;value1&#34;, # optional
            &#34;param2&#34;: &#34;value2&#34;, # optional
            &#34;game_instances&#34;: [ # this is required
                {&#34;id&#34;: &lt;value&gt;, &#34;initial_prompt&#34;: ... },
                {&#34;id&#34;: &lt;value&gt;, &#34;initial_prompt&#34;: ... }
            ]
        }
    ]
    &#34;&#34;&#34;

    def __init__(self, path: str):
        &#34;&#34;&#34;
        Args:
            path: The path to the game.
        &#34;&#34;&#34;
        super().__init__(path=path)
        self.instances = dict(experiments=list())

    def add_experiment(self, experiment_name: str, dialogue_partners: List[Tuple[str, str]] = None) -&gt; Dict:
        &#34;&#34;&#34;Add an experiment to the game benchmark.
        Experiments are sets of instances, usually with different experimental variables than other experiments in a
        game benchmark.
        Call this method and adjust the returned dict to configure the experiment.
        For game instances use add_game_instance!
        Args:
            experiment_name: Name of the new game experiment.
            dialogue_partners: A list of partner definitions for which the experiment will run.
        Returns:
            A new game experiment dict.
        &#34;&#34;&#34;
        experiment = collections.OrderedDict(name=experiment_name)
        if dialogue_partners:
            experiment[&#34;dialogue_partners&#34;] = dialogue_partners
        experiment[&#34;game_instances&#34;] = list()
        self.instances[&#34;experiments&#34;].append(experiment)
        return experiment

    def add_game_instance(self, experiment: Dict, game_id):
        &#34;&#34;&#34;Add an instance to an experiment.
        An instance holds all data to run a single episode of a game.
        Call this method and adjust the returned dict to configure the instance.
        Args:
            experiment: The experiment to which a new game instance should be added.
            game_id: Identifier of the new game instance.
        Returns:
            A new game instance dict.
        &#34;&#34;&#34;
        game_instance = dict(game_id=game_id)
        experiment[&#34;game_instances&#34;].append(game_instance)
        return game_instance

    def on_generate(self, **kwargs):
        &#34;&#34;&#34;Game-specific instance generation.
        This method is intended for creation of instances and experiments for a game benchmark. Use the add_experiment
        and add_game_instance methods to create the game benchmark.
        Must be implemented!
        Args:
            kwargs: Keyword arguments (or dict) with data controlling instance generation.
        &#34;&#34;&#34;
        raise NotImplementedError()

    def generate(self, filename=&#34;instances.json&#34;, **kwargs):
        &#34;&#34;&#34;Generate the game benchmark and store the instances JSON file.
        Intended to not be modified by inheriting classes, modify on_generate instead.
        Args:
            filename: The name of the instances JSON file to be stored in the &#39;in&#39; subdirectory. Defaults to
                &#39;instances.json&#39;.
            kwargs: Keyword arguments (or dict) to pass to the on_generate method.
        &#34;&#34;&#34;
        self.on_generate(**kwargs)
        self.store_file(self.instances, filename, sub_dir=&#34;in&#34;)</code></pre>
</details>
<div class="desc"><p>Create all game instances for a game benchmark.
Results in an instances.json with the following structure:</p>
<p>"experiments": [ # this is required
{
"name": <experiment-name>, # this is required
"param1": "value1", # optional
"param2": "value2", # optional
"game_instances": [ # this is required
{"id": <value>, "initial_prompt": &hellip; },
{"id": <value>, "initial_prompt": &hellip; }
]
}
]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong></dt>
<dd>The path to the game.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="clemcore.clemgame.resources.GameResourceLocator" href="resources.html#clemcore.clemgame.resources.GameResourceLocator">GameResourceLocator</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="clemcore.clemgame.GameInstanceGenerator.add_experiment"><code class="name flex">
<span>def <span class="ident">add_experiment</span></span>(<span>self, experiment_name: str, dialogue_partners: List[Tuple[str, str]] = None) ‑> Dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_experiment(self, experiment_name: str, dialogue_partners: List[Tuple[str, str]] = None) -&gt; Dict:
    &#34;&#34;&#34;Add an experiment to the game benchmark.
    Experiments are sets of instances, usually with different experimental variables than other experiments in a
    game benchmark.
    Call this method and adjust the returned dict to configure the experiment.
    For game instances use add_game_instance!
    Args:
        experiment_name: Name of the new game experiment.
        dialogue_partners: A list of partner definitions for which the experiment will run.
    Returns:
        A new game experiment dict.
    &#34;&#34;&#34;
    experiment = collections.OrderedDict(name=experiment_name)
    if dialogue_partners:
        experiment[&#34;dialogue_partners&#34;] = dialogue_partners
    experiment[&#34;game_instances&#34;] = list()
    self.instances[&#34;experiments&#34;].append(experiment)
    return experiment</code></pre>
</details>
<div class="desc"><p>Add an experiment to the game benchmark.
Experiments are sets of instances, usually with different experimental variables than other experiments in a
game benchmark.
Call this method and adjust the returned dict to configure the experiment.
For game instances use add_game_instance!</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>experiment_name</code></strong></dt>
<dd>Name of the new game experiment.</dd>
<dt><strong><code>dialogue_partners</code></strong></dt>
<dd>A list of partner definitions for which the experiment will run.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A new game experiment dict.</p></div>
</dd>
<dt id="clemcore.clemgame.GameInstanceGenerator.add_game_instance"><code class="name flex">
<span>def <span class="ident">add_game_instance</span></span>(<span>self, experiment: Dict, game_id)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_game_instance(self, experiment: Dict, game_id):
    &#34;&#34;&#34;Add an instance to an experiment.
    An instance holds all data to run a single episode of a game.
    Call this method and adjust the returned dict to configure the instance.
    Args:
        experiment: The experiment to which a new game instance should be added.
        game_id: Identifier of the new game instance.
    Returns:
        A new game instance dict.
    &#34;&#34;&#34;
    game_instance = dict(game_id=game_id)
    experiment[&#34;game_instances&#34;].append(game_instance)
    return game_instance</code></pre>
</details>
<div class="desc"><p>Add an instance to an experiment.
An instance holds all data to run a single episode of a game.
Call this method and adjust the returned dict to configure the instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>experiment</code></strong></dt>
<dd>The experiment to which a new game instance should be added.</dd>
<dt><strong><code>game_id</code></strong></dt>
<dd>Identifier of the new game instance.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A new game instance dict.</p></div>
</dd>
<dt id="clemcore.clemgame.GameInstanceGenerator.generate"><code class="name flex">
<span>def <span class="ident">generate</span></span>(<span>self, filename='instances.json', **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate(self, filename=&#34;instances.json&#34;, **kwargs):
    &#34;&#34;&#34;Generate the game benchmark and store the instances JSON file.
    Intended to not be modified by inheriting classes, modify on_generate instead.
    Args:
        filename: The name of the instances JSON file to be stored in the &#39;in&#39; subdirectory. Defaults to
            &#39;instances.json&#39;.
        kwargs: Keyword arguments (or dict) to pass to the on_generate method.
    &#34;&#34;&#34;
    self.on_generate(**kwargs)
    self.store_file(self.instances, filename, sub_dir=&#34;in&#34;)</code></pre>
</details>
<div class="desc"><p>Generate the game benchmark and store the instances JSON file.
Intended to not be modified by inheriting classes, modify on_generate instead.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong></dt>
<dd>The name of the instances JSON file to be stored in the 'in' subdirectory. Defaults to
'instances.json'.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Keyword arguments (or dict) to pass to the on_generate method.</dd>
</dl></div>
</dd>
<dt id="clemcore.clemgame.GameInstanceGenerator.on_generate"><code class="name flex">
<span>def <span class="ident">on_generate</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_generate(self, **kwargs):
    &#34;&#34;&#34;Game-specific instance generation.
    This method is intended for creation of instances and experiments for a game benchmark. Use the add_experiment
    and add_game_instance methods to create the game benchmark.
    Must be implemented!
    Args:
        kwargs: Keyword arguments (or dict) with data controlling instance generation.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
<div class="desc"><p>Game-specific instance generation.
This method is intended for creation of instances and experiments for a game benchmark. Use the add_experiment
and add_game_instance methods to create the game benchmark.
Must be implemented!</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Keyword arguments (or dict) with data controlling instance generation.</dd>
</dl></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="clemcore.clemgame.resources.GameResourceLocator" href="resources.html#clemcore.clemgame.resources.GameResourceLocator">GameResourceLocator</a></b></code>:
<ul class="hlist">
<li><code><a title="clemcore.clemgame.resources.GameResourceLocator.load_csv" href="resources.html#clemcore.clemgame.resources.GameResourceLocator.load_csv">load_csv</a></code></li>
<li><code><a title="clemcore.clemgame.resources.GameResourceLocator.load_file" href="resources.html#clemcore.clemgame.resources.GameResourceLocator.load_file">load_file</a></code></li>
<li><code><a title="clemcore.clemgame.resources.GameResourceLocator.load_instances" href="resources.html#clemcore.clemgame.resources.GameResourceLocator.load_instances">load_instances</a></code></li>
<li><code><a title="clemcore.clemgame.resources.GameResourceLocator.load_json" href="resources.html#clemcore.clemgame.resources.GameResourceLocator.load_json">load_json</a></code></li>
<li><code><a title="clemcore.clemgame.resources.GameResourceLocator.load_results_json" href="resources.html#clemcore.clemgame.resources.GameResourceLocator.load_results_json">load_results_json</a></code></li>
<li><code><a title="clemcore.clemgame.resources.GameResourceLocator.load_template" href="resources.html#clemcore.clemgame.resources.GameResourceLocator.load_template">load_template</a></code></li>
<li><code><a title="clemcore.clemgame.resources.GameResourceLocator.store_file" href="resources.html#clemcore.clemgame.resources.GameResourceLocator.store_file">store_file</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="clemcore.clemgame.GameInstanceIterator"><code class="flex name class">
<span>class <span class="ident">GameInstanceIterator</span></span>
<span>(</span><span>instances, do_shuffle=False, reset=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GameInstanceIterator:
    &#34;&#34;&#34;Class to iterate over game instances.&#34;&#34;&#34;
    def __init__(self, instances, do_shuffle=False, reset=True):
        &#34;&#34;&#34;
        Args:
            instances: A list of instances.
            do_shuffle: If True, the order of instances will be randomly shuffled on resetting a GameInstanceIterator
                object.
            reset: If True, GameInstanceIterator object gets reset when in initialized.
        &#34;&#34;&#34;
        assert instances is not None, &#34;Instances must be given&#34;
        self._instances = instances
        self._do_shuffle = do_shuffle
        self._queue = []
        if reset:
            self.reset()

    def __iter__(self):
        return self

    def __next__(self) -&gt; Tuple[Dict, Dict]:
        try:
            return self._queue.pop(0)
        except IndexError:
            raise StopIteration()

    def __len__(self):
        return len(self._queue)

    def clone(self) -&gt; &#34;GameInstanceIterator&#34;:
        &#34;&#34;&#34;Clone GameInstanceIterator object, creating an exact copy without references to the original.&#34;&#34;&#34;
        _clone = GameInstanceIterator(self._instances, do_shuffle=self._do_shuffle, reset=False)
        _clone._queue = deepcopy(self._queue)
        return _clone

    def reset(self) -&gt; &#34;GameInstanceIterator&#34;:
        &#34;&#34;&#34;Reset GameInstanceIterator object.&#34;&#34;&#34;
        self._queue = []
        for index, experiment in enumerate(self._instances[&#34;experiments&#34;]):
            filtered_experiment = {k: experiment[k] for k in experiment if k != &#39;game_instances&#39;}
            filtered_experiment[&#34;index&#34;] = index
            for game_instance in experiment[&#34;game_instances&#34;]:
                self._queue.append((filtered_experiment, game_instance))
        if self._do_shuffle:
            random.shuffle(self._queue)
        return self</code></pre>
</details>
<div class="desc"><p>Class to iterate over game instances.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>instances</code></strong></dt>
<dd>A list of instances.</dd>
<dt><strong><code>do_shuffle</code></strong></dt>
<dd>If True, the order of instances will be randomly shuffled on resetting a GameInstanceIterator
object.</dd>
<dt><strong><code>reset</code></strong></dt>
<dd>If True, GameInstanceIterator object gets reset when in initialized.</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="clemcore.clemgame.GameInstanceIterator.clone"><code class="name flex">
<span>def <span class="ident">clone</span></span>(<span>self) ‑> <a title="clemcore.clemgame.benchmark.GameInstanceIterator" href="benchmark.html#clemcore.clemgame.benchmark.GameInstanceIterator">GameInstanceIterator</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clone(self) -&gt; &#34;GameInstanceIterator&#34;:
    &#34;&#34;&#34;Clone GameInstanceIterator object, creating an exact copy without references to the original.&#34;&#34;&#34;
    _clone = GameInstanceIterator(self._instances, do_shuffle=self._do_shuffle, reset=False)
    _clone._queue = deepcopy(self._queue)
    return _clone</code></pre>
</details>
<div class="desc"><p>Clone GameInstanceIterator object, creating an exact copy without references to the original.</p></div>
</dd>
<dt id="clemcore.clemgame.GameInstanceIterator.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self) ‑> <a title="clemcore.clemgame.benchmark.GameInstanceIterator" href="benchmark.html#clemcore.clemgame.benchmark.GameInstanceIterator">GameInstanceIterator</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self) -&gt; &#34;GameInstanceIterator&#34;:
    &#34;&#34;&#34;Reset GameInstanceIterator object.&#34;&#34;&#34;
    self._queue = []
    for index, experiment in enumerate(self._instances[&#34;experiments&#34;]):
        filtered_experiment = {k: experiment[k] for k in experiment if k != &#39;game_instances&#39;}
        filtered_experiment[&#34;index&#34;] = index
        for game_instance in experiment[&#34;game_instances&#34;]:
            self._queue.append((filtered_experiment, game_instance))
    if self._do_shuffle:
        random.shuffle(self._queue)
    return self</code></pre>
</details>
<div class="desc"><p>Reset GameInstanceIterator object.</p></div>
</dd>
</dl>
</dd>
<dt id="clemcore.clemgame.GameMaster"><code class="flex name class">
<span>class <span class="ident">GameMaster</span></span>
<span>(</span><span>name: str,<br>path: str,<br>experiment: Dict,<br>player_models: List[<a title="clemcore.backends.model_registry.Model" href="../backends/model_registry.html#clemcore.backends.model_registry.Model">Model</a>])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GameMaster(abc.ABC):
    &#34;&#34;&#34;Base class to contain game-specific functionality.

    A GameMaster (sub-)class

    - prepares a concrete game instance
    - plays an episode of a game instance
    - records a game episode
    - evaluates the game episode records
    - builds the interaction transcripts
    &#34;&#34;&#34;

    def __init__(self, name: str, path: str, experiment: Dict, player_models: List[backends.Model]):
        &#34;&#34;&#34;
        Args:
            name: The name of the game (as specified in game_registry).
            path: Path to the game (as specified in game_registry).
            experiment: Parameters of the current experiment, that is, parameters that are the same for all game
                instances this experiment contains. (Note: These values could be stored in each instance as well, but it
                is recommended to store them only once on the experiment level.)
            player_models: Player models to use for one or two players.
            game_recorder: Enables to log each interaction in the game.
                           Resulting records can be stored to an interactions.json.
        &#34;&#34;&#34;
        self.game_name = name
        self.experiment: Dict = experiment
        self.player_models: List[backends.Model] = player_models
        self._game_recorder = NoopGameRecorder()
        self.game_resources = GameResourceLocator(name, path)  # could be obsolete, when all info is in the instances

    @property
    def game_recorder(self):
        return self._game_recorder

    @game_recorder.setter
    def game_recorder(self, game_recorder):
        self._game_recorder = game_recorder

    def load_json(self, file_path: Union[str, Path]):
        return self.game_resources.load_json(file_path)

    def load_template(self, file_path: Union[str, Path]):
        return self.game_resources.load_template(file_path)

    def log_to_self(self, type_: str, value: Any):
        &#34;&#34;&#34;Logs an action of the passed type from GM to GM.
        This is a logging method, and will not add anything to the conversation history.
        Args:
            type_: The type of the action to be logged.
            value: The content value of the action to be logged. Must be JSON serializable.
        &#34;&#34;&#34;
        self._game_recorder.log_event(&#34;GM&#34;, &#34;GM&#34;, {&#39;type&#39;: type_, &#39;content&#39;: value})

    def log_key(self, key: str, value: Any):
        self._game_recorder.log_key(key, value)

    def log_players(self, players_dict):
        self._game_recorder.log_players(players_dict)

    def log_next_round(self):
        self._game_recorder.log_next_round()

    def log_event(self, from_, to, action):
        self._game_recorder.log_event(from_, to, action)

    def store_records(self, results_root, dialogue_pair_desc, game_record_dir):
        self._game_recorder.store_records(results_root, dialogue_pair_desc, game_record_dir)

    @abc.abstractmethod
    def setup(self, **kwargs):
        &#34;&#34;&#34;Load resources and prepare everything to play the game.
        Needs to log the players dictionary via self.log_players(players_dict).
        Called by the game&#39;s GameBenchmark run method for each game instance.
        Must be implemented for proper games.
        Args:
            kwargs: Keyword arguments used to set up the GameMaster instance.
        &#34;&#34;&#34;
        pass

    @abc.abstractmethod
    def play(self) -&gt; None:
        &#34;&#34;&#34;Play the game (multiple turns of a specific game instance).
        Must be implemented for proper games.&#34;&#34;&#34;
        pass</code></pre>
</details>
<div class="desc"><p>Base class to contain game-specific functionality.</p>
<p>A GameMaster (sub-)class</p>
<ul>
<li>prepares a concrete game instance</li>
<li>plays an episode of a game instance</li>
<li>records a game episode</li>
<li>evaluates the game episode records</li>
<li>builds the interaction transcripts</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>The name of the game (as specified in game_registry).</dd>
<dt><strong><code>path</code></strong></dt>
<dd>Path to the game (as specified in game_registry).</dd>
<dt><strong><code>experiment</code></strong></dt>
<dd>Parameters of the current experiment, that is, parameters that are the same for all game
instances this experiment contains. (Note: These values could be stored in each instance as well, but it
is recommended to store them only once on the experiment level.)</dd>
<dt><strong><code>player_models</code></strong></dt>
<dd>Player models to use for one or two players.</dd>
<dt><strong><code>game_recorder</code></strong></dt>
<dd>Enables to log each interaction in the game.
Resulting records can be stored to an interactions.json.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="clemcore.clemgame.master.DialogueGameMaster" href="master.html#clemcore.clemgame.master.DialogueGameMaster">DialogueGameMaster</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="clemcore.clemgame.GameMaster.game_recorder"><code class="name">prop <span class="ident">game_recorder</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def game_recorder(self):
    return self._game_recorder</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="clemcore.clemgame.GameMaster.load_json"><code class="name flex">
<span>def <span class="ident">load_json</span></span>(<span>self, file_path: str | pathlib.Path)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_json(self, file_path: Union[str, Path]):
    return self.game_resources.load_json(file_path)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="clemcore.clemgame.GameMaster.load_template"><code class="name flex">
<span>def <span class="ident">load_template</span></span>(<span>self, file_path: str | pathlib.Path)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_template(self, file_path: Union[str, Path]):
    return self.game_resources.load_template(file_path)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="clemcore.clemgame.GameMaster.log_event"><code class="name flex">
<span>def <span class="ident">log_event</span></span>(<span>self, from_, to, action)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log_event(self, from_, to, action):
    self._game_recorder.log_event(from_, to, action)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="clemcore.clemgame.GameMaster.log_key"><code class="name flex">
<span>def <span class="ident">log_key</span></span>(<span>self, key: str, value: Any)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log_key(self, key: str, value: Any):
    self._game_recorder.log_key(key, value)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="clemcore.clemgame.GameMaster.log_next_round"><code class="name flex">
<span>def <span class="ident">log_next_round</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log_next_round(self):
    self._game_recorder.log_next_round()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="clemcore.clemgame.GameMaster.log_players"><code class="name flex">
<span>def <span class="ident">log_players</span></span>(<span>self, players_dict)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log_players(self, players_dict):
    self._game_recorder.log_players(players_dict)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="clemcore.clemgame.GameMaster.log_to_self"><code class="name flex">
<span>def <span class="ident">log_to_self</span></span>(<span>self, type_: str, value: Any)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log_to_self(self, type_: str, value: Any):
    &#34;&#34;&#34;Logs an action of the passed type from GM to GM.
    This is a logging method, and will not add anything to the conversation history.
    Args:
        type_: The type of the action to be logged.
        value: The content value of the action to be logged. Must be JSON serializable.
    &#34;&#34;&#34;
    self._game_recorder.log_event(&#34;GM&#34;, &#34;GM&#34;, {&#39;type&#39;: type_, &#39;content&#39;: value})</code></pre>
</details>
<div class="desc"><p>Logs an action of the passed type from GM to GM.
This is a logging method, and will not add anything to the conversation history.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>type_</code></strong></dt>
<dd>The type of the action to be logged.</dd>
<dt><strong><code>value</code></strong></dt>
<dd>The content value of the action to be logged. Must be JSON serializable.</dd>
</dl></div>
</dd>
<dt id="clemcore.clemgame.GameMaster.play"><code class="name flex">
<span>def <span class="ident">play</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def play(self) -&gt; None:
    &#34;&#34;&#34;Play the game (multiple turns of a specific game instance).
    Must be implemented for proper games.&#34;&#34;&#34;
    pass</code></pre>
</details>
<div class="desc"><p>Play the game (multiple turns of a specific game instance).
Must be implemented for proper games.</p></div>
</dd>
<dt id="clemcore.clemgame.GameMaster.setup"><code class="name flex">
<span>def <span class="ident">setup</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def setup(self, **kwargs):
    &#34;&#34;&#34;Load resources and prepare everything to play the game.
    Needs to log the players dictionary via self.log_players(players_dict).
    Called by the game&#39;s GameBenchmark run method for each game instance.
    Must be implemented for proper games.
    Args:
        kwargs: Keyword arguments used to set up the GameMaster instance.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
<div class="desc"><p>Load resources and prepare everything to play the game.
Needs to log the players dictionary via self.log_players(players_dict).
Called by the game's GameBenchmark run method for each game instance.
Must be implemented for proper games.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Keyword arguments used to set up the GameMaster instance.</dd>
</dl></div>
</dd>
<dt id="clemcore.clemgame.GameMaster.store_records"><code class="name flex">
<span>def <span class="ident">store_records</span></span>(<span>self, results_root, dialogue_pair_desc, game_record_dir)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def store_records(self, results_root, dialogue_pair_desc, game_record_dir):
    self._game_recorder.store_records(results_root, dialogue_pair_desc, game_record_dir)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="clemcore.clemgame.GameRecorder"><code class="flex name class">
<span>class <span class="ident">GameRecorder</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GameRecorder(ABC):
    &#34;&#34;&#34;Generic class for creating game records.&#34;&#34;&#34;
    @abstractmethod
    def log_next_round(self):
        &#34;&#34;&#34;Call this method to group interactions per turn.&#34;&#34;&#34;
        pass

    @abstractmethod
    def log_key(self, key, value):
        &#34;&#34;&#34;Add a key and value to the internal log.
        Args:
            key: A string to identify the kind of log entry to be made.
            value: The content of the entry to be logged.
        &#34;&#34;&#34;
        pass

    @abstractmethod
    def log_players(self, players_dic):
        &#34;&#34;&#34;Log/record the players in this game episode.
        Args:
            players_dic: Dictionary of players in this game episode.
        &#34;&#34;&#34;
        pass

    @abstractmethod
    def log_event(self, from_, to, action, call=None):
        &#34;&#34;&#34;Add an event to the internal log.
        It can be only an action or an action plus an API call that should have the same timestamp as the action.
        Args:
            from_: The identifier string of the Player/GM that originated the action.
            to: The identifier string of the Player/GM target of the action.
            action: The benchmark action to be logged.
            call: If given, this is a tuple whose first element is the input prompt object (after API-specific
                manipulation) as passed to the API and the second element is the raw response object as returned by the
                API.
        &#34;&#34;&#34;
        pass

    @abstractmethod
    def store_records(self, results_root, dialogue_pair_desc, game_record_dir):
        &#34;&#34;&#34;Store benchmark records.
        Raise warnings if a mandatory element is empty or format is wrong.
        Args:
            results_root: The root path to the results directory.
            dialogue_pair_desc: A string combining the Player pair names to be used as directory name.
            game_record_dir: The game&#39;s record directory path.
        &#34;&#34;&#34;
        pass</code></pre>
</details>
<div class="desc"><p>Generic class for creating game records.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="clemcore.clemgame.recorder.DefaultGameRecorder" href="recorder.html#clemcore.clemgame.recorder.DefaultGameRecorder">DefaultGameRecorder</a></li>
<li><a title="clemcore.clemgame.recorder.NoopGameRecorder" href="recorder.html#clemcore.clemgame.recorder.NoopGameRecorder">NoopGameRecorder</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="clemcore.clemgame.GameRecorder.log_event"><code class="name flex">
<span>def <span class="ident">log_event</span></span>(<span>self, from_, to, action, call=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def log_event(self, from_, to, action, call=None):
    &#34;&#34;&#34;Add an event to the internal log.
    It can be only an action or an action plus an API call that should have the same timestamp as the action.
    Args:
        from_: The identifier string of the Player/GM that originated the action.
        to: The identifier string of the Player/GM target of the action.
        action: The benchmark action to be logged.
        call: If given, this is a tuple whose first element is the input prompt object (after API-specific
            manipulation) as passed to the API and the second element is the raw response object as returned by the
            API.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
<div class="desc"><p>Add an event to the internal log.
It can be only an action or an action plus an API call that should have the same timestamp as the action.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>from_</code></strong></dt>
<dd>The identifier string of the Player/GM that originated the action.</dd>
<dt><strong><code>to</code></strong></dt>
<dd>The identifier string of the Player/GM target of the action.</dd>
<dt><strong><code>action</code></strong></dt>
<dd>The benchmark action to be logged.</dd>
<dt><strong><code>call</code></strong></dt>
<dd>If given, this is a tuple whose first element is the input prompt object (after API-specific
manipulation) as passed to the API and the second element is the raw response object as returned by the
API.</dd>
</dl></div>
</dd>
<dt id="clemcore.clemgame.GameRecorder.log_key"><code class="name flex">
<span>def <span class="ident">log_key</span></span>(<span>self, key, value)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def log_key(self, key, value):
    &#34;&#34;&#34;Add a key and value to the internal log.
    Args:
        key: A string to identify the kind of log entry to be made.
        value: The content of the entry to be logged.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
<div class="desc"><p>Add a key and value to the internal log.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>key</code></strong></dt>
<dd>A string to identify the kind of log entry to be made.</dd>
<dt><strong><code>value</code></strong></dt>
<dd>The content of the entry to be logged.</dd>
</dl></div>
</dd>
<dt id="clemcore.clemgame.GameRecorder.log_next_round"><code class="name flex">
<span>def <span class="ident">log_next_round</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def log_next_round(self):
    &#34;&#34;&#34;Call this method to group interactions per turn.&#34;&#34;&#34;
    pass</code></pre>
</details>
<div class="desc"><p>Call this method to group interactions per turn.</p></div>
</dd>
<dt id="clemcore.clemgame.GameRecorder.log_players"><code class="name flex">
<span>def <span class="ident">log_players</span></span>(<span>self, players_dic)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def log_players(self, players_dic):
    &#34;&#34;&#34;Log/record the players in this game episode.
    Args:
        players_dic: Dictionary of players in this game episode.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
<div class="desc"><p>Log/record the players in this game episode.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>players_dic</code></strong></dt>
<dd>Dictionary of players in this game episode.</dd>
</dl></div>
</dd>
<dt id="clemcore.clemgame.GameRecorder.store_records"><code class="name flex">
<span>def <span class="ident">store_records</span></span>(<span>self, results_root, dialogue_pair_desc, game_record_dir)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def store_records(self, results_root, dialogue_pair_desc, game_record_dir):
    &#34;&#34;&#34;Store benchmark records.
    Raise warnings if a mandatory element is empty or format is wrong.
    Args:
        results_root: The root path to the results directory.
        dialogue_pair_desc: A string combining the Player pair names to be used as directory name.
        game_record_dir: The game&#39;s record directory path.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
<div class="desc"><p>Store benchmark records.
Raise warnings if a mandatory element is empty or format is wrong.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>results_root</code></strong></dt>
<dd>The root path to the results directory.</dd>
<dt><strong><code>dialogue_pair_desc</code></strong></dt>
<dd>A string combining the Player pair names to be used as directory name.</dd>
<dt><strong><code>game_record_dir</code></strong></dt>
<dd>The game's record directory path.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="clemcore.clemgame.GameRegistry"><code class="flex name class">
<span>class <span class="ident">GameRegistry</span></span>
<span>(</span><span>game_specs: List[<a title="clemcore.clemgame.registry.GameSpec" href="registry.html#clemcore.clemgame.registry.GameSpec">GameSpec</a>] = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GameRegistry:

    def __init__(self, game_specs: List[GameSpec] = None):
        if game_specs is None:
            game_specs = []
        self._game_specs = game_specs

    def __len__(self):
        return len(self._game_specs)

    def __iter__(self):
        return iter(self._game_specs)

    def get_game_specs(self):
        return self._game_specs

    @classmethod
    def from_directories_and_cwd_files(cls):
        &#34;&#34;&#34;
        Lookup game specs in the following locations:
        (1) Look for a (optional) game_registry.json in current working directory (relative to script execution)
        (2) Look for sub-directories of the current working director that contain a clemgame.json (depth=2)
        Model specs found in the (1) are listed before (2) allowing to &#39;favor&#39; the ones in (1).

        Note:
        Game specs defined via (1) require the &#39;game_path&#39; attribute
        while for game specs found via (2) this is set automatically.

        :return: model registry with model specs
        &#34;&#34;&#34;
        game_registry = cls()
        try:
            game_registry_path = os.path.join(os.getcwd(), &#34;game_registry.json&#34;)
            with open(game_registry_path, encoding=&#39;utf-8&#39;) as f:
                game_registry.register_from_list(json.load(f), game_registry_path)
        except Exception as e:
            logger.debug(&#34;File lookup failed with exception: %s&#34;, e)
        game_registry.register_from_directories(os.getcwd(), 0)
        return game_registry

    def register_from_list(self, game_specs: List[Dict], lookup_source: str = None) -&gt; &#34;GameRegistry&#34;:
        for game_spec_dict in game_specs:
            try:
                if lookup_source and (&#34;lookup_source&#34; not in game_spec_dict):
                    game_spec_dict[&#34;lookup_source&#34;] = lookup_source
                game_spec = GameSpec.from_dict(game_spec_dict)
                self._game_specs.append(game_spec)
            except Exception as e:
                stdout_logger.warning(&#34;Game spec could not be loaded because: %s&#34;, e)
        return self

    def register_from_directories(self, current_directory: str, depth, max_depth=3):
        # deep first search to keep order of sorted directory names
        if depth &gt; max_depth:
            return
        candidate_file_path = os.path.join(current_directory, &#34;clemgame.json&#34;)
        try:
            if os.path.exists(candidate_file_path):
                game_specs = GameSpec.from_directory(current_directory)
                self._game_specs.extend(game_specs)
                return
            for current_file in sorted(os.listdir(current_directory)):
                file_path = os.path.join(current_directory, current_file)
                if not os.path.isdir(file_path):
                    continue
                if current_file.startswith(&#34;.&#34;):
                    continue
                if current_file in [&#34;venv&#34;, &#34;__pycache__&#34;, &#34;docs&#34;,
                                    &#34;in&#34;, &#34;resources&#34;, &#34;utils&#34;, &#34;evaluation&#34;, &#34;files&#34;]:
                    continue
                self.register_from_directories(file_path, depth + 1, max_depth)
        except PermissionError:
            pass  # ignore
        except Exception as e:  # most likely a problem with the json file
            stdout_logger.warning(&#34;Lookup failed at &#39;%s&#39; with exception: %s&#34;, candidate_file_path, e)

    def get_game_specs_that_unify_with(self, game_selector: Union[str, Dict, GameSpec], verbose: bool = True) -&gt; List[
        GameSpec]:
        &#34;&#34;&#34;Select a list of GameSpecs from the game registry by unifying game spec dict or game name.
        Args:
            game_selector: String name of the game matching the &#39;game_name&#39; value of the game registry entry to select, OR a
                GameSpec-like dict, OR a GameSpec object.
                A passed GameSpec-like dict can EITHER contain the &#39;benchmark&#39; key with a list of benchmark versions value,
                in which case all games that have matching benchmark version strings in their &#39;benchmark&#39; key values are
                selected, OR contain one or more other GameSpec keys, in which case all games that unify with the given key
                values are selected. If there is the &#39;benchmark&#39; key, only benchmark versions are checked!
                For example: {&#39;benchmark&#39;:[&#39;v2&#39;]} will select all games that have &#39;v2&#39; in their &#39;benchmark&#39; key value list.
                {&#39;main_game&#39;: &#39;wordle&#39;} will select all wordle variants, as their game registry entries have the &#39;main_game&#39;
                key value &#39;wordle&#39;.
        Returns:
            A list of GameSpec instances from the game registry corresponding to the passed game string, dict or GameSpec.
        Raises:
            ValueError: No game specification matching the passed game was found in the game registry.
        &#34;&#34;&#34;
        # check if passed game is parseable JSON:
        game_is_dict = False
        try:
            game_selector = game_selector.replace(&#34;&#39;&#34;, &#39;&#34;&#39;)
            game_selector = json.loads(game_selector)
            game_is_dict = True
        except Exception:
            logger.info(f&#34;Passed game &#39;{game_selector}&#39; does not parse as JSON!&#34;)
            pass

        # convert passed JSON to GameSpec for unification:
        game_is_gamespec = False
        if game_is_dict:
            game_selector = GameSpec.from_dict(game_selector, allow_underspecified=True)
            game_is_gamespec = True
        elif type(game_selector) == GameSpec:
            game_is_gamespec = True

        selected_game_specs = []
        if game_selector == &#34;all&#34;:
            selected_game_specs = self._game_specs
        elif game_is_gamespec:
            # iterate over game registry:
            for registered_game_spec in self._game_specs:

                if hasattr(game_selector, &#39;benchmark&#39;):
                    # passed game spec specifies benchmark version
                    for benchmark_version in game_selector.benchmark:
                        if benchmark_version in registered_game_spec.benchmark:
                            if registered_game_spec.game_file_exists():
                                selected_game_specs.append(registered_game_spec)

                else:
                    # get unifying entries:
                    unifying_game_spec = None
                    try:
                        unifying_game_spec = game_selector.unify(registered_game_spec)
                        if unifying_game_spec.game_file_exists():
                            # print(f&#34;Found unifying game registry entry: {unifying_game_spec}&#34;)
                            selected_game_specs.append(unifying_game_spec)
                    except ValueError:
                        continue
        else:
            # return first entry that matches game_name
            for registered_game_spec in self._game_specs:
                if registered_game_spec[&#34;game_name&#34;] == game_selector:
                    selected_game_specs = [registered_game_spec]
                    break
        if selected_game_specs:
            if verbose:
                if game_is_gamespec:
                    stdout_logger.info(f&#34;Found &#39;{len(selected_game_specs)}&#39; game matching the game_selector=&#34;
                                       f&#34;{game_selector.to_string()}&#34;)
                else:
                    stdout_logger.info(f&#34;Found &#39;{len(selected_game_specs)}&#39; game matching the game_selector=&#34;
                                       f&#34;{json.dumps(game_selector, separators=(&#39;,&#39;, &#39;:&#39;), indent=None)}&#34;)
                if len(selected_game_specs) == 1:
                    stdout_logger.info(selected_game_specs[0].to_pretty_string())
                else:
                    for game_spec in selected_game_specs:
                        stdout_logger.info(game_spec.to_string())
            return selected_game_specs
        raise ValueError(f&#34;No games found matching the game selector=&#39;{game_selector}&#39;.&#34;)
        # extension to select subset of games
        # (postponed because it introduces more complexity
        # on things like how to specify specific episodes (which could, however be integrated into the game spec
        # and then selected through the custom game_spec for a specific run),
        # and thus can be easier done by looping over an
        # explicit list of games with a bash script (see clembench/scripts/run_benchmark.sh)

        # select relevant games from game registry
        # selected_games = []
        # properties = {}
        # is_single_game = True
        # if game_name.endswith(&#34;.json&#34;):
        #     is_single_game = False
        #     with open(os.path.join(file_utils.project_root(), game_name)) as f:
        #         properties = json.load(f)
        #     # add default values
        #     if &#34;lang&#34; not in properties:
        #         properties[&#34;language&#34;] = &#34;en&#34;
        #     if &#34;image&#34; not in properties:
        #         properties[&#34;image&#34;] = &#34;none&#34;
        #     # examples:
        #     # {&#34;benchmark&#34; : &#34;2.0&#34;} # run all English textual games marked for benchmark version 2.0
        #     # {&#34;benchmark&#34; : &#34;1.5&#34;, &#34;lang&#34;: &#34;ru&#34;} # run all games of benchmark version 1.5 for which Russian versions exist
        #     # {&#34;main_game&#34;: &#34;matchit&#34;} # to run all English textual matchit game versions
        #     # {&#34;image&#34;: &#34;single&#34;, &#34;main_game&#34;: &#34;matchit&#34;} # to run all English multimodal matchit game versions
        #
        # if is_single_game:
        #     # return first entry that matches game_name
        #     for game in game_registry:
        #         if game[&#34;game_name&#34;] == game_name:
        #             return game
        # else:
        #     for game in game_registry:
        #         if game.matches(properties):
        #             selected_games.append(game)
        #
        # if len(selected_games) == 0:
        #     raise ValueError(f&#34;No games found matching the given specification &#39;{game_name}&#39;. &#34;
        #                      &#34;Make sure game name or attribute names and values match game_registry.json&#34;)
        # return selected_games</code></pre>
</details>
<div class="desc"></div>
<h3>Static methods</h3>
<dl>
<dt id="clemcore.clemgame.GameRegistry.from_directories_and_cwd_files"><code class="name flex">
<span>def <span class="ident">from_directories_and_cwd_files</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Lookup game specs in the following locations:
(1) Look for a (optional) game_registry.json in current working directory (relative to script execution)
(2) Look for sub-directories of the current working director that contain a clemgame.json (depth=2)
Model specs found in the (1) are listed before (2) allowing to 'favor' the ones in (1).</p>
<p>Note:
Game specs defined via (1) require the 'game_path' attribute
while for game specs found via (2) this is set automatically.</p>
<p>:return: model registry with model specs</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="clemcore.clemgame.GameRegistry.get_game_specs"><code class="name flex">
<span>def <span class="ident">get_game_specs</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_game_specs(self):
    return self._game_specs</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="clemcore.clemgame.GameRegistry.get_game_specs_that_unify_with"><code class="name flex">
<span>def <span class="ident">get_game_specs_that_unify_with</span></span>(<span>self,<br>game_selector: str | Dict | <a title="clemcore.clemgame.registry.GameSpec" href="registry.html#clemcore.clemgame.registry.GameSpec">GameSpec</a>,<br>verbose: bool = True) ‑> List[<a title="clemcore.clemgame.registry.GameSpec" href="registry.html#clemcore.clemgame.registry.GameSpec">GameSpec</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_game_specs_that_unify_with(self, game_selector: Union[str, Dict, GameSpec], verbose: bool = True) -&gt; List[
    GameSpec]:
    &#34;&#34;&#34;Select a list of GameSpecs from the game registry by unifying game spec dict or game name.
    Args:
        game_selector: String name of the game matching the &#39;game_name&#39; value of the game registry entry to select, OR a
            GameSpec-like dict, OR a GameSpec object.
            A passed GameSpec-like dict can EITHER contain the &#39;benchmark&#39; key with a list of benchmark versions value,
            in which case all games that have matching benchmark version strings in their &#39;benchmark&#39; key values are
            selected, OR contain one or more other GameSpec keys, in which case all games that unify with the given key
            values are selected. If there is the &#39;benchmark&#39; key, only benchmark versions are checked!
            For example: {&#39;benchmark&#39;:[&#39;v2&#39;]} will select all games that have &#39;v2&#39; in their &#39;benchmark&#39; key value list.
            {&#39;main_game&#39;: &#39;wordle&#39;} will select all wordle variants, as their game registry entries have the &#39;main_game&#39;
            key value &#39;wordle&#39;.
    Returns:
        A list of GameSpec instances from the game registry corresponding to the passed game string, dict or GameSpec.
    Raises:
        ValueError: No game specification matching the passed game was found in the game registry.
    &#34;&#34;&#34;
    # check if passed game is parseable JSON:
    game_is_dict = False
    try:
        game_selector = game_selector.replace(&#34;&#39;&#34;, &#39;&#34;&#39;)
        game_selector = json.loads(game_selector)
        game_is_dict = True
    except Exception:
        logger.info(f&#34;Passed game &#39;{game_selector}&#39; does not parse as JSON!&#34;)
        pass

    # convert passed JSON to GameSpec for unification:
    game_is_gamespec = False
    if game_is_dict:
        game_selector = GameSpec.from_dict(game_selector, allow_underspecified=True)
        game_is_gamespec = True
    elif type(game_selector) == GameSpec:
        game_is_gamespec = True

    selected_game_specs = []
    if game_selector == &#34;all&#34;:
        selected_game_specs = self._game_specs
    elif game_is_gamespec:
        # iterate over game registry:
        for registered_game_spec in self._game_specs:

            if hasattr(game_selector, &#39;benchmark&#39;):
                # passed game spec specifies benchmark version
                for benchmark_version in game_selector.benchmark:
                    if benchmark_version in registered_game_spec.benchmark:
                        if registered_game_spec.game_file_exists():
                            selected_game_specs.append(registered_game_spec)

            else:
                # get unifying entries:
                unifying_game_spec = None
                try:
                    unifying_game_spec = game_selector.unify(registered_game_spec)
                    if unifying_game_spec.game_file_exists():
                        # print(f&#34;Found unifying game registry entry: {unifying_game_spec}&#34;)
                        selected_game_specs.append(unifying_game_spec)
                except ValueError:
                    continue
    else:
        # return first entry that matches game_name
        for registered_game_spec in self._game_specs:
            if registered_game_spec[&#34;game_name&#34;] == game_selector:
                selected_game_specs = [registered_game_spec]
                break
    if selected_game_specs:
        if verbose:
            if game_is_gamespec:
                stdout_logger.info(f&#34;Found &#39;{len(selected_game_specs)}&#39; game matching the game_selector=&#34;
                                   f&#34;{game_selector.to_string()}&#34;)
            else:
                stdout_logger.info(f&#34;Found &#39;{len(selected_game_specs)}&#39; game matching the game_selector=&#34;
                                   f&#34;{json.dumps(game_selector, separators=(&#39;,&#39;, &#39;:&#39;), indent=None)}&#34;)
            if len(selected_game_specs) == 1:
                stdout_logger.info(selected_game_specs[0].to_pretty_string())
            else:
                for game_spec in selected_game_specs:
                    stdout_logger.info(game_spec.to_string())
        return selected_game_specs
    raise ValueError(f&#34;No games found matching the game selector=&#39;{game_selector}&#39;.&#34;)
    # extension to select subset of games
    # (postponed because it introduces more complexity
    # on things like how to specify specific episodes (which could, however be integrated into the game spec
    # and then selected through the custom game_spec for a specific run),
    # and thus can be easier done by looping over an
    # explicit list of games with a bash script (see clembench/scripts/run_benchmark.sh)

    # select relevant games from game registry
    # selected_games = []
    # properties = {}
    # is_single_game = True
    # if game_name.endswith(&#34;.json&#34;):
    #     is_single_game = False
    #     with open(os.path.join(file_utils.project_root(), game_name)) as f:
    #         properties = json.load(f)
    #     # add default values
    #     if &#34;lang&#34; not in properties:
    #         properties[&#34;language&#34;] = &#34;en&#34;
    #     if &#34;image&#34; not in properties:
    #         properties[&#34;image&#34;] = &#34;none&#34;
    #     # examples:
    #     # {&#34;benchmark&#34; : &#34;2.0&#34;} # run all English textual games marked for benchmark version 2.0
    #     # {&#34;benchmark&#34; : &#34;1.5&#34;, &#34;lang&#34;: &#34;ru&#34;} # run all games of benchmark version 1.5 for which Russian versions exist
    #     # {&#34;main_game&#34;: &#34;matchit&#34;} # to run all English textual matchit game versions
    #     # {&#34;image&#34;: &#34;single&#34;, &#34;main_game&#34;: &#34;matchit&#34;} # to run all English multimodal matchit game versions
    #
    # if is_single_game:
    #     # return first entry that matches game_name
    #     for game in game_registry:
    #         if game[&#34;game_name&#34;] == game_name:
    #             return game
    # else:
    #     for game in game_registry:
    #         if game.matches(properties):
    #             selected_games.append(game)
    #
    # if len(selected_games) == 0:
    #     raise ValueError(f&#34;No games found matching the given specification &#39;{game_name}&#39;. &#34;
    #                      &#34;Make sure game name or attribute names and values match game_registry.json&#34;)
    # return selected_games</code></pre>
</details>
<div class="desc"><p>Select a list of GameSpecs from the game registry by unifying game spec dict or game name.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>game_selector</code></strong></dt>
<dd>String name of the game matching the 'game_name' value of the game registry entry to select, OR a
GameSpec-like dict, OR a GameSpec object.
A passed GameSpec-like dict can EITHER contain the 'benchmark' key with a list of benchmark versions value,
in which case all games that have matching benchmark version strings in their 'benchmark' key values are
selected, OR contain one or more other GameSpec keys, in which case all games that unify with the given key
values are selected. If there is the 'benchmark' key, only benchmark versions are checked!
For example: {'benchmark':['v2']} will select all games that have 'v2' in their 'benchmark' key value list.
{'main_game': 'wordle'} will select all wordle variants, as their game registry entries have the 'main_game'
key value 'wordle'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A list of GameSpec instances from the game registry corresponding to the passed game string, dict or GameSpec.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>No game specification matching the passed game was found in the game registry.</dd>
</dl></div>
</dd>
<dt id="clemcore.clemgame.GameRegistry.register_from_directories"><code class="name flex">
<span>def <span class="ident">register_from_directories</span></span>(<span>self, current_directory: str, depth, max_depth=3)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register_from_directories(self, current_directory: str, depth, max_depth=3):
    # deep first search to keep order of sorted directory names
    if depth &gt; max_depth:
        return
    candidate_file_path = os.path.join(current_directory, &#34;clemgame.json&#34;)
    try:
        if os.path.exists(candidate_file_path):
            game_specs = GameSpec.from_directory(current_directory)
            self._game_specs.extend(game_specs)
            return
        for current_file in sorted(os.listdir(current_directory)):
            file_path = os.path.join(current_directory, current_file)
            if not os.path.isdir(file_path):
                continue
            if current_file.startswith(&#34;.&#34;):
                continue
            if current_file in [&#34;venv&#34;, &#34;__pycache__&#34;, &#34;docs&#34;,
                                &#34;in&#34;, &#34;resources&#34;, &#34;utils&#34;, &#34;evaluation&#34;, &#34;files&#34;]:
                continue
            self.register_from_directories(file_path, depth + 1, max_depth)
    except PermissionError:
        pass  # ignore
    except Exception as e:  # most likely a problem with the json file
        stdout_logger.warning(&#34;Lookup failed at &#39;%s&#39; with exception: %s&#34;, candidate_file_path, e)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="clemcore.clemgame.GameRegistry.register_from_list"><code class="name flex">
<span>def <span class="ident">register_from_list</span></span>(<span>self, game_specs: List[Dict], lookup_source: str = None) ‑> <a title="clemcore.clemgame.registry.GameRegistry" href="registry.html#clemcore.clemgame.registry.GameRegistry">GameRegistry</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register_from_list(self, game_specs: List[Dict], lookup_source: str = None) -&gt; &#34;GameRegistry&#34;:
    for game_spec_dict in game_specs:
        try:
            if lookup_source and (&#34;lookup_source&#34; not in game_spec_dict):
                game_spec_dict[&#34;lookup_source&#34;] = lookup_source
            game_spec = GameSpec.from_dict(game_spec_dict)
            self._game_specs.append(game_spec)
        except Exception as e:
            stdout_logger.warning(&#34;Game spec could not be loaded because: %s&#34;, e)
    return self</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="clemcore.clemgame.GameResourceLocator"><code class="flex name class">
<span>class <span class="ident">GameResourceLocator</span></span>
<span>(</span><span>name: str = None, path: str = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GameResourceLocator(abc.ABC):
    &#34;&#34;&#34;
    Provides access to game specific resources and results (based on game path and results directory)

    Note: You should access resource only via the game resource locator! The locator knows how to refer to them.
    For example use: `gm.load_json(&#34;my_file&#34;)` which is located directly at your game directory `game/my_file.json`.
    You can access subdirectories by giving `gm.load_json(&#34;sub/my_file&#34;)` in `game/sub/my_file.json`.

    Makes a distinction between game files (which live in the game path specified in `self.game_path`)
    and the results files, which live in the results directory (`clembench/results` if not set otherwise)
    under `results/dialogue_pair/self.game_name/`
    &#34;&#34;&#34;

    def __init__(self, name: str = None, path: str = None):
        &#34;&#34;&#34;

        Args:
            name: name of the game (optional, because not needed for GameInstanceGenerator)
            path: path to the game (optional, because not needed for GameScorer)
        &#34;&#34;&#34;
        self.game_name = name  # for building results structure
        self.game_path = path  # for accessing game resources

    def __load_game_file(self, file_path: Union[str, Path], file_ending: str = None) -&gt; str:
        &#34;&#34;&#34;Load a file from a clemgame. Assumes the file to be an utf8-encoded (text) file.
        Args:
            file_path: Relative path to the file starting from game path.
            file_ending: The file type suffix of the file.
        Returns:
            The file content as returned by open-&gt;read().
        &#34;&#34;&#34;
        if file_ending and not file_path.endswith(file_ending):
            file_path = file_path + file_ending
        fp = os.path.join(self.game_path, file_path)
        with open(fp, encoding=&#39;utf8&#39;) as f:
            data = f.read()
        return data

    def load_instances(self, instances_name):
        &#34;&#34;&#34;Construct instances path and return json object of the instance file.
        Args:
            game_path: Path to the game directory.
            instances_name: Name of the instances JSON file.
        Returns:
            A dict containing the contents of the given instances file.
        &#34;&#34;&#34;
        if instances_name is None:
            instances_name = &#34;instances&#34;
        return self.load_json(f&#34;in/{instances_name}&#34;)

    def load_template(self, file_path: Union[str, Path]) -&gt; str:
        &#34;&#34;&#34;Load a .template file from the game directory.
        Args:
            file_path: Relative path to the file starting from game path.
        Returns:
            The template file content as string.
        &#34;&#34;&#34;
        return self.__load_game_file(file_path, file_ending=&#34;.template&#34;)

    def load_json(self, file_path: Union[str, Path]) -&gt; Dict:
        &#34;&#34;&#34;Load a .json file from your game directory.
        Args:
            file_path: Relative path to the file starting from game path.
        Returns:
            The JSON file content as dict.
        &#34;&#34;&#34;
        data = self.__load_game_file(file_path, file_ending=&#34;.json&#34;)
        return json.loads(data)

    def load_results_json(self, file_name: str, results_dir: str, dialogue_pair: str) -&gt; Dict:
        &#34;&#34;&#34;Load a .json file from the results directory for this game.
        Args:
            file_name: The name of the JSON file. Can have subdirectories e.g. &#34;sub/my_file&#34;.
            results_dir: The string path to the results directory.
            dialogue_pair: The name of the model pair directory. The directory name is retrieved from the results
                directory file structure by classes/methods that use this method.
        Returns:
            The JSON file content as dict.
        &#34;&#34;&#34;
        &#34;&#34;&#34;
        todo: this is a bit delicate: we need to duplicate the code from self.load_json, 
        b.c. either we provide for all load_json cases the path from outside e.g. self.load_json(self.game_path)
        or we move this method outside GameResourceLocator, because the results is not necessarily a game file;
        considering this, we actually could also make the results live in the games (but this not yet done).
        Such a refactoring would indeed need more time and breaks things. 
        &#34;&#34;&#34;
        file_ending = &#34;.json&#34;
        if not file_name.endswith(file_ending):
            file_name = file_name + file_ending
        fp = os.path.join(results_dir, dialogue_pair, self.game_name, file_name)
        with open(fp, encoding=&#39;utf8&#39;) as f:
            data = f.read()
        data = json.loads(data)
        return data

    def load_csv(self, file_name: str) -&gt; List:
        &#34;&#34;&#34;Load a .csv file from your game directory.
        Args:
            file_name: The name of the CSV file. Can have subdirectories e.g. &#34;sub/my_file&#34;.
        Returns:
            A list version of the CSV file content.
        &#34;&#34;&#34;
        # iso8859_2 was required for opening nytcrosswords.csv for clues in wordle
        rows = []
        fp = os.path.join(self.game_path, file_name)
        with open(fp, encoding=&#39;iso8859_2&#39;) as csv_file:
            data = csv.reader(csv_file, delimiter=&#39;,&#39;)
            for row in data:
                rows.append(row)
        return rows

    def load_file(self, file_name: str, file_ending: str = None) -&gt; str:
        &#34;&#34;&#34;Load an arbitrary file from your game directory.
        Args:
            file_name: The name of the file. Can have subdirectories e.g. &#34;sub/my_file&#34;.
            file_ending: The file type suffix of the file. Optional: Can be part of file_name.
        Returns:
            The file content as string.
        &#34;&#34;&#34;
        return self.__load_game_file(file_name, file_ending=file_ending)

    def store_file(self, data, file_name: str, sub_dir: str = None):
        &#34;&#34;&#34;Store a file in your game directory.
        Args:
            data: The data to store in the file.
            file_name: The name of the file. Can have subdirectories e.g. &#34;sub/my_file&#34;.
            sub_dir: The subdirectory to store the file in. Automatically created when given; otherwise an error will
                be thrown.
        &#34;&#34;&#34;
        fp = store_file(data, file_name, self.game_path, sub_dir=sub_dir)
        module_logger.info(&#34;Game file stored to %s&#34;, fp)</code></pre>
</details>
<div class="desc"><p>Provides access to game specific resources and results (based on game path and results directory)</p>
<p>Note: You should access resource only via the game resource locator! The locator knows how to refer to them.
For example use: <code>gm.load_json("my_file")</code> which is located directly at your game directory <code>game/my_file.json</code>.
You can access subdirectories by giving <code>gm.load_json("sub/my_file")</code> in <code>game/sub/my_file.json</code>.</p>
<p>Makes a distinction between game files (which live in the game path specified in <code>self.game_path</code>)
and the results files, which live in the results directory (<code>clembench/results</code> if not set otherwise)
under <code>results/dialogue_pair/self.game_name/</code></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>name of the game (optional, because not needed for GameInstanceGenerator)</dd>
<dt><strong><code>path</code></strong></dt>
<dd>path to the game (optional, because not needed for GameScorer)</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="clemcore.clemgame.benchmark.GameBenchmark" href="benchmark.html#clemcore.clemgame.benchmark.GameBenchmark">GameBenchmark</a></li>
<li><a title="clemcore.clemgame.instances.GameInstanceGenerator" href="instances.html#clemcore.clemgame.instances.GameInstanceGenerator">GameInstanceGenerator</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="clemcore.clemgame.GameResourceLocator.load_csv"><code class="name flex">
<span>def <span class="ident">load_csv</span></span>(<span>self, file_name: str) ‑> List</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_csv(self, file_name: str) -&gt; List:
    &#34;&#34;&#34;Load a .csv file from your game directory.
    Args:
        file_name: The name of the CSV file. Can have subdirectories e.g. &#34;sub/my_file&#34;.
    Returns:
        A list version of the CSV file content.
    &#34;&#34;&#34;
    # iso8859_2 was required for opening nytcrosswords.csv for clues in wordle
    rows = []
    fp = os.path.join(self.game_path, file_name)
    with open(fp, encoding=&#39;iso8859_2&#39;) as csv_file:
        data = csv.reader(csv_file, delimiter=&#39;,&#39;)
        for row in data:
            rows.append(row)
    return rows</code></pre>
</details>
<div class="desc"><p>Load a .csv file from your game directory.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_name</code></strong></dt>
<dd>The name of the CSV file. Can have subdirectories e.g. "sub/my_file".</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A list version of the CSV file content.</p></div>
</dd>
<dt id="clemcore.clemgame.GameResourceLocator.load_file"><code class="name flex">
<span>def <span class="ident">load_file</span></span>(<span>self, file_name: str, file_ending: str = None) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_file(self, file_name: str, file_ending: str = None) -&gt; str:
    &#34;&#34;&#34;Load an arbitrary file from your game directory.
    Args:
        file_name: The name of the file. Can have subdirectories e.g. &#34;sub/my_file&#34;.
        file_ending: The file type suffix of the file. Optional: Can be part of file_name.
    Returns:
        The file content as string.
    &#34;&#34;&#34;
    return self.__load_game_file(file_name, file_ending=file_ending)</code></pre>
</details>
<div class="desc"><p>Load an arbitrary file from your game directory.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_name</code></strong></dt>
<dd>The name of the file. Can have subdirectories e.g. "sub/my_file".</dd>
<dt><strong><code>file_ending</code></strong></dt>
<dd>The file type suffix of the file. Optional: Can be part of file_name.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The file content as string.</p></div>
</dd>
<dt id="clemcore.clemgame.GameResourceLocator.load_instances"><code class="name flex">
<span>def <span class="ident">load_instances</span></span>(<span>self, instances_name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_instances(self, instances_name):
    &#34;&#34;&#34;Construct instances path and return json object of the instance file.
    Args:
        game_path: Path to the game directory.
        instances_name: Name of the instances JSON file.
    Returns:
        A dict containing the contents of the given instances file.
    &#34;&#34;&#34;
    if instances_name is None:
        instances_name = &#34;instances&#34;
    return self.load_json(f&#34;in/{instances_name}&#34;)</code></pre>
</details>
<div class="desc"><p>Construct instances path and return json object of the instance file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>game_path</code></strong></dt>
<dd>Path to the game directory.</dd>
<dt><strong><code>instances_name</code></strong></dt>
<dd>Name of the instances JSON file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A dict containing the contents of the given instances file.</p></div>
</dd>
<dt id="clemcore.clemgame.GameResourceLocator.load_json"><code class="name flex">
<span>def <span class="ident">load_json</span></span>(<span>self, file_path: str | pathlib.Path) ‑> Dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_json(self, file_path: Union[str, Path]) -&gt; Dict:
    &#34;&#34;&#34;Load a .json file from your game directory.
    Args:
        file_path: Relative path to the file starting from game path.
    Returns:
        The JSON file content as dict.
    &#34;&#34;&#34;
    data = self.__load_game_file(file_path, file_ending=&#34;.json&#34;)
    return json.loads(data)</code></pre>
</details>
<div class="desc"><p>Load a .json file from your game directory.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_path</code></strong></dt>
<dd>Relative path to the file starting from game path.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The JSON file content as dict.</p></div>
</dd>
<dt id="clemcore.clemgame.GameResourceLocator.load_results_json"><code class="name flex">
<span>def <span class="ident">load_results_json</span></span>(<span>self, file_name: str, results_dir: str, dialogue_pair: str) ‑> Dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_results_json(self, file_name: str, results_dir: str, dialogue_pair: str) -&gt; Dict:
    &#34;&#34;&#34;Load a .json file from the results directory for this game.
    Args:
        file_name: The name of the JSON file. Can have subdirectories e.g. &#34;sub/my_file&#34;.
        results_dir: The string path to the results directory.
        dialogue_pair: The name of the model pair directory. The directory name is retrieved from the results
            directory file structure by classes/methods that use this method.
    Returns:
        The JSON file content as dict.
    &#34;&#34;&#34;
    &#34;&#34;&#34;
    todo: this is a bit delicate: we need to duplicate the code from self.load_json, 
    b.c. either we provide for all load_json cases the path from outside e.g. self.load_json(self.game_path)
    or we move this method outside GameResourceLocator, because the results is not necessarily a game file;
    considering this, we actually could also make the results live in the games (but this not yet done).
    Such a refactoring would indeed need more time and breaks things. 
    &#34;&#34;&#34;
    file_ending = &#34;.json&#34;
    if not file_name.endswith(file_ending):
        file_name = file_name + file_ending
    fp = os.path.join(results_dir, dialogue_pair, self.game_name, file_name)
    with open(fp, encoding=&#39;utf8&#39;) as f:
        data = f.read()
    data = json.loads(data)
    return data</code></pre>
</details>
<div class="desc"><p>Load a .json file from the results directory for this game.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_name</code></strong></dt>
<dd>The name of the JSON file. Can have subdirectories e.g. "sub/my_file".</dd>
<dt><strong><code>results_dir</code></strong></dt>
<dd>The string path to the results directory.</dd>
<dt><strong><code>dialogue_pair</code></strong></dt>
<dd>The name of the model pair directory. The directory name is retrieved from the results
directory file structure by classes/methods that use this method.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The JSON file content as dict.</p></div>
</dd>
<dt id="clemcore.clemgame.GameResourceLocator.load_template"><code class="name flex">
<span>def <span class="ident">load_template</span></span>(<span>self, file_path: str | pathlib.Path) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_template(self, file_path: Union[str, Path]) -&gt; str:
    &#34;&#34;&#34;Load a .template file from the game directory.
    Args:
        file_path: Relative path to the file starting from game path.
    Returns:
        The template file content as string.
    &#34;&#34;&#34;
    return self.__load_game_file(file_path, file_ending=&#34;.template&#34;)</code></pre>
</details>
<div class="desc"><p>Load a .template file from the game directory.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_path</code></strong></dt>
<dd>Relative path to the file starting from game path.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The template file content as string.</p></div>
</dd>
<dt id="clemcore.clemgame.GameResourceLocator.store_file"><code class="name flex">
<span>def <span class="ident">store_file</span></span>(<span>self, data, file_name: str, sub_dir: str = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def store_file(self, data, file_name: str, sub_dir: str = None):
    &#34;&#34;&#34;Store a file in your game directory.
    Args:
        data: The data to store in the file.
        file_name: The name of the file. Can have subdirectories e.g. &#34;sub/my_file&#34;.
        sub_dir: The subdirectory to store the file in. Automatically created when given; otherwise an error will
            be thrown.
    &#34;&#34;&#34;
    fp = store_file(data, file_name, self.game_path, sub_dir=sub_dir)
    module_logger.info(&#34;Game file stored to %s&#34;, fp)</code></pre>
</details>
<div class="desc"><p>Store a file in your game directory.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>The data to store in the file.</dd>
<dt><strong><code>file_name</code></strong></dt>
<dd>The name of the file. Can have subdirectories e.g. "sub/my_file".</dd>
<dt><strong><code>sub_dir</code></strong></dt>
<dd>The subdirectory to store the file in. Automatically created when given; otherwise an error will
be thrown.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="clemcore.clemgame.GameScorer"><code class="flex name class">
<span>class <span class="ident">GameScorer</span></span>
<span>(</span><span>name: str, experiment: Dict, game_instance: Dict)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GameScorer:
    &#34;&#34;&#34;Calculates scores based on interaction logs.&#34;&#34;&#34;

    def __init__(self, name: str, experiment: Dict, game_instance: Dict):
        &#34;&#34;&#34;
        Args:
            name: The name of the game.
            experiment: The experiment to score.
            game_instance: The game instance to score.
        &#34;&#34;&#34;
        self.game_name = name
        self.experiment = experiment
        self.game_instance = game_instance
        &#34;&#34;&#34; Stores values of score computation &#34;&#34;&#34;
        self.scores = {
            &#34;turn scores&#34;: {},
            &#34;episode scores&#34;: {},
        }

    # mapworld games use this method directly ... because they overwrite store_scores to store images
    # we should maybe add an on_store_scores hook for this already providing the full path to the episode dir
    def store_results_file(self, data, file_name: str, dialogue_pair: str,
                           sub_dir: str = None, results_dir: str = None):
        store_results_file(self.game_name, data, file_name,
                           dialogue_pair=dialogue_pair,
                           sub_dir=sub_dir,
                           results_dir=results_dir)

    def store_scores(self, results_root: str, dialogue_pair: str, game_record_dir: str):
        &#34;&#34;&#34;Store calculated scores to scores.json file.
        Args:
            results_root: The root path to the results directory.
            dialogue_pair: A string path to the Player pair results directory.
            game_record_dir: The game&#39;s record directory path.
        &#34;&#34;&#34;
        store_results_file(self.game_name, self.scores, &#34;scores.json&#34;,
                           dialogue_pair=dialogue_pair,
                           sub_dir=game_record_dir,
                           results_dir=results_root)

    def log_turn_score(self, turn_idx, score_name, score_value):
        &#34;&#34;&#34;Record a turn-level score for a single turn.
        Args:
            turn_idx: The turn index for the turn the score is to be recorded for.
            score_name: The name of the turn-level score to record.
            score_value: The value to be recorded for the turn-level score for this turn.
        &#34;&#34;&#34;
        if isinstance(score_value, bool):
            module_logger.warning(f&#34;{self.game_name}: Score {score_name} value is boolean, this can break the eval!&#34;)
        if turn_idx not in self.scores[&#34;turn scores&#34;]:
            self.scores[&#34;turn scores&#34;][turn_idx] = {}
        if score_name in self.scores[&#34;turn scores&#34;][turn_idx]:
            module_logger.warning(f&#34;{self.game_name}: Score {score_name} overwritten at turn {turn_idx}!&#34;)
        self.scores[&#34;turn scores&#34;][turn_idx][score_name] = score_value
        module_logger.info(f&#34;{self.game_name}: Logged turn {turn_idx} score {score_name}={score_value}.&#34;)

    def log_episode_score(self, score_name, score_value):
        &#34;&#34;&#34;Record an episode-level score for a single turn.
        Args:
            score_name: The name of the episode-level score to record.
            score_value: The value to be recorded for the episode-level score.
        &#34;&#34;&#34;
        if score_name in self.scores[&#34;episode scores&#34;]:
            module_logger.warning(f&#34;{self.game_name}: Episode score {score_name} overwritten!&#34;)
        self.scores[&#34;episode scores&#34;][score_name] = score_value
        module_logger.info(f&#34;{self.game_name}: Logged episode score {score_name}={score_value}.&#34;)

    def compute_scores(self, episode_interactions: Dict) -&gt; None:
        &#34;&#34;&#34;Compute and log scores for a game episode.
        This method is used to perform complete scoring of an episode.
        Args:
            episode_interactions: Dict containing the episode&#39;s interactions. This contains the actions recorded during
                a benchmark run.
        &#34;&#34;&#34;
        self.score_turns(episode_interactions)
        self.score_game(episode_interactions)

    def score_turns(self, episode_interactions: Dict) -&gt; None:
        &#34;&#34;&#34;Iterate over episode turns, calculate and log turn-level scores.
        This method is intended to contain any game-specific turn-level scoring. Must be implemented!
        Use the log_turn_score method to log turn-level scores.
        Args:
            episode_interactions: Dict containing the episode&#39;s interactions. This contains the actions recorded during
                a benchmark run.
        &#34;&#34;&#34;
        # Loop over turns, calculate and log turn-specific scores
        raise NotImplementedError()

    def score_game(self, episode_interactions: Dict) -&gt; None:
        &#34;&#34;&#34;Calculate and record standard clembench metric scores for an episode.
        Args:
            episode_interactions: Dict containing the episode&#39;s interactions. This contains the actions recorded during
                a benchmark run.
        &#34;&#34;&#34;
        self.score_game_end(episode_interactions)
        self.score_requests(episode_interactions)
        self.log_main_score(episode_interactions)

    def score_game_end(self, episode_interactions: Dict) -&gt; None:
        &#34;&#34;&#34;Calculate and record the ABORTED, LOSE and SUCCESS standard clembench metric scores.
        Convenience method to cover mandatory clembench metric scores, so their calculation does not need to be
        implemented anew for each new clemgame.
        Args:
            episode_interactions: Dict containing the episode&#39;s interactions. This contains the actions recorded during
                a benchmark run.
        &#34;&#34;&#34;
        aborted = int(episode_interactions[METRIC_ABORTED])
        lose = int(episode_interactions[METRIC_LOSE]) if not aborted else 0
        success = 1 - lose if not aborted else 0

        self.log_episode_score(METRIC_ABORTED, aborted)
        self.log_episode_score(METRIC_LOSE, lose)
        self.log_episode_score(METRIC_SUCCESS, success)

    def score_requests(self, episode_interactions: Dict):
        &#34;&#34;&#34;Calculate and record standard request-based clembench metric scores.
        Records total request count, parsed, violated, and success ratio of parsed requests over all requests in an
        episode.
        Convenience method to cover mandatory clembench metric scores, so their calculation does not need to be
        implemented anew for each new clemgame.
        Args:
            episode_interactions: Dict containing the episode&#39;s interactions. This contains the actions recorded during
                a benchmark run.
        &#34;&#34;&#34;
        request_count = episode_interactions[
            METRIC_REQUEST_COUNT]  # could also be calculated by adding parsed and violated requests
        parsed_requests = episode_interactions[METRIC_REQUEST_COUNT_PARSED]
        violated_requests = episode_interactions[METRIC_REQUEST_COUNT_VIOLATED]

        self.log_episode_score(METRIC_REQUEST_COUNT, request_count)
        self.log_episode_score(METRIC_REQUEST_COUNT_PARSED, parsed_requests)
        self.log_episode_score(METRIC_REQUEST_COUNT_VIOLATED, violated_requests)
        self.log_episode_score(METRIC_REQUEST_SUCCESS, parsed_requests / request_count)

    def log_main_score(self, episode_interactions: Dict):
        &#34;&#34;&#34;Record the game&#39;s main score.
        Replace this method with a method that calculates and logs the clemgame&#39;s main score aka BENCH_SCORE.
        Must be implemented! Recording BENCH_SCORE is mandatory.
        Args:
            episode_interactions: Dict containing the episode&#39;s interactions. This contains the actions recorded during
                a benchmark run.
        &#34;&#34;&#34;
        raise NotImplementedError()</code></pre>
</details>
<div class="desc"><p>Calculates scores based on interaction logs.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>The name of the game.</dd>
<dt><strong><code>experiment</code></strong></dt>
<dd>The experiment to score.</dd>
<dt><strong><code>game_instance</code></strong></dt>
<dd>The game instance to score.</dd>
</dl></div>
<h3>Instance variables</h3>
<dl>
<dt id="clemcore.clemgame.GameScorer.game_instance"><code class="name">var <span class="ident">game_instance</span></code></dt>
<dd>
<div class="desc"><p>Stores values of score computation</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="clemcore.clemgame.GameScorer.compute_scores"><code class="name flex">
<span>def <span class="ident">compute_scores</span></span>(<span>self, episode_interactions: Dict) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_scores(self, episode_interactions: Dict) -&gt; None:
    &#34;&#34;&#34;Compute and log scores for a game episode.
    This method is used to perform complete scoring of an episode.
    Args:
        episode_interactions: Dict containing the episode&#39;s interactions. This contains the actions recorded during
            a benchmark run.
    &#34;&#34;&#34;
    self.score_turns(episode_interactions)
    self.score_game(episode_interactions)</code></pre>
</details>
<div class="desc"><p>Compute and log scores for a game episode.
This method is used to perform complete scoring of an episode.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>episode_interactions</code></strong></dt>
<dd>Dict containing the episode's interactions. This contains the actions recorded during
a benchmark run.</dd>
</dl></div>
</dd>
<dt id="clemcore.clemgame.GameScorer.log_episode_score"><code class="name flex">
<span>def <span class="ident">log_episode_score</span></span>(<span>self, score_name, score_value)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log_episode_score(self, score_name, score_value):
    &#34;&#34;&#34;Record an episode-level score for a single turn.
    Args:
        score_name: The name of the episode-level score to record.
        score_value: The value to be recorded for the episode-level score.
    &#34;&#34;&#34;
    if score_name in self.scores[&#34;episode scores&#34;]:
        module_logger.warning(f&#34;{self.game_name}: Episode score {score_name} overwritten!&#34;)
    self.scores[&#34;episode scores&#34;][score_name] = score_value
    module_logger.info(f&#34;{self.game_name}: Logged episode score {score_name}={score_value}.&#34;)</code></pre>
</details>
<div class="desc"><p>Record an episode-level score for a single turn.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>score_name</code></strong></dt>
<dd>The name of the episode-level score to record.</dd>
<dt><strong><code>score_value</code></strong></dt>
<dd>The value to be recorded for the episode-level score.</dd>
</dl></div>
</dd>
<dt id="clemcore.clemgame.GameScorer.log_main_score"><code class="name flex">
<span>def <span class="ident">log_main_score</span></span>(<span>self, episode_interactions: Dict)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log_main_score(self, episode_interactions: Dict):
    &#34;&#34;&#34;Record the game&#39;s main score.
    Replace this method with a method that calculates and logs the clemgame&#39;s main score aka BENCH_SCORE.
    Must be implemented! Recording BENCH_SCORE is mandatory.
    Args:
        episode_interactions: Dict containing the episode&#39;s interactions. This contains the actions recorded during
            a benchmark run.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
<div class="desc"><p>Record the game's main score.
Replace this method with a method that calculates and logs the clemgame's main score aka BENCH_SCORE.
Must be implemented! Recording BENCH_SCORE is mandatory.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>episode_interactions</code></strong></dt>
<dd>Dict containing the episode's interactions. This contains the actions recorded during
a benchmark run.</dd>
</dl></div>
</dd>
<dt id="clemcore.clemgame.GameScorer.log_turn_score"><code class="name flex">
<span>def <span class="ident">log_turn_score</span></span>(<span>self, turn_idx, score_name, score_value)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log_turn_score(self, turn_idx, score_name, score_value):
    &#34;&#34;&#34;Record a turn-level score for a single turn.
    Args:
        turn_idx: The turn index for the turn the score is to be recorded for.
        score_name: The name of the turn-level score to record.
        score_value: The value to be recorded for the turn-level score for this turn.
    &#34;&#34;&#34;
    if isinstance(score_value, bool):
        module_logger.warning(f&#34;{self.game_name}: Score {score_name} value is boolean, this can break the eval!&#34;)
    if turn_idx not in self.scores[&#34;turn scores&#34;]:
        self.scores[&#34;turn scores&#34;][turn_idx] = {}
    if score_name in self.scores[&#34;turn scores&#34;][turn_idx]:
        module_logger.warning(f&#34;{self.game_name}: Score {score_name} overwritten at turn {turn_idx}!&#34;)
    self.scores[&#34;turn scores&#34;][turn_idx][score_name] = score_value
    module_logger.info(f&#34;{self.game_name}: Logged turn {turn_idx} score {score_name}={score_value}.&#34;)</code></pre>
</details>
<div class="desc"><p>Record a turn-level score for a single turn.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>turn_idx</code></strong></dt>
<dd>The turn index for the turn the score is to be recorded for.</dd>
<dt><strong><code>score_name</code></strong></dt>
<dd>The name of the turn-level score to record.</dd>
<dt><strong><code>score_value</code></strong></dt>
<dd>The value to be recorded for the turn-level score for this turn.</dd>
</dl></div>
</dd>
<dt id="clemcore.clemgame.GameScorer.score_game"><code class="name flex">
<span>def <span class="ident">score_game</span></span>(<span>self, episode_interactions: Dict) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def score_game(self, episode_interactions: Dict) -&gt; None:
    &#34;&#34;&#34;Calculate and record standard clembench metric scores for an episode.
    Args:
        episode_interactions: Dict containing the episode&#39;s interactions. This contains the actions recorded during
            a benchmark run.
    &#34;&#34;&#34;
    self.score_game_end(episode_interactions)
    self.score_requests(episode_interactions)
    self.log_main_score(episode_interactions)</code></pre>
</details>
<div class="desc"><p>Calculate and record standard clembench metric scores for an episode.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>episode_interactions</code></strong></dt>
<dd>Dict containing the episode's interactions. This contains the actions recorded during
a benchmark run.</dd>
</dl></div>
</dd>
<dt id="clemcore.clemgame.GameScorer.score_game_end"><code class="name flex">
<span>def <span class="ident">score_game_end</span></span>(<span>self, episode_interactions: Dict) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def score_game_end(self, episode_interactions: Dict) -&gt; None:
    &#34;&#34;&#34;Calculate and record the ABORTED, LOSE and SUCCESS standard clembench metric scores.
    Convenience method to cover mandatory clembench metric scores, so their calculation does not need to be
    implemented anew for each new clemgame.
    Args:
        episode_interactions: Dict containing the episode&#39;s interactions. This contains the actions recorded during
            a benchmark run.
    &#34;&#34;&#34;
    aborted = int(episode_interactions[METRIC_ABORTED])
    lose = int(episode_interactions[METRIC_LOSE]) if not aborted else 0
    success = 1 - lose if not aborted else 0

    self.log_episode_score(METRIC_ABORTED, aborted)
    self.log_episode_score(METRIC_LOSE, lose)
    self.log_episode_score(METRIC_SUCCESS, success)</code></pre>
</details>
<div class="desc"><p>Calculate and record the ABORTED, LOSE and SUCCESS standard clembench metric scores.
Convenience method to cover mandatory clembench metric scores, so their calculation does not need to be
implemented anew for each new clemgame.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>episode_interactions</code></strong></dt>
<dd>Dict containing the episode's interactions. This contains the actions recorded during
a benchmark run.</dd>
</dl></div>
</dd>
<dt id="clemcore.clemgame.GameScorer.score_requests"><code class="name flex">
<span>def <span class="ident">score_requests</span></span>(<span>self, episode_interactions: Dict)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def score_requests(self, episode_interactions: Dict):
    &#34;&#34;&#34;Calculate and record standard request-based clembench metric scores.
    Records total request count, parsed, violated, and success ratio of parsed requests over all requests in an
    episode.
    Convenience method to cover mandatory clembench metric scores, so their calculation does not need to be
    implemented anew for each new clemgame.
    Args:
        episode_interactions: Dict containing the episode&#39;s interactions. This contains the actions recorded during
            a benchmark run.
    &#34;&#34;&#34;
    request_count = episode_interactions[
        METRIC_REQUEST_COUNT]  # could also be calculated by adding parsed and violated requests
    parsed_requests = episode_interactions[METRIC_REQUEST_COUNT_PARSED]
    violated_requests = episode_interactions[METRIC_REQUEST_COUNT_VIOLATED]

    self.log_episode_score(METRIC_REQUEST_COUNT, request_count)
    self.log_episode_score(METRIC_REQUEST_COUNT_PARSED, parsed_requests)
    self.log_episode_score(METRIC_REQUEST_COUNT_VIOLATED, violated_requests)
    self.log_episode_score(METRIC_REQUEST_SUCCESS, parsed_requests / request_count)</code></pre>
</details>
<div class="desc"><p>Calculate and record standard request-based clembench metric scores.
Records total request count, parsed, violated, and success ratio of parsed requests over all requests in an
episode.
Convenience method to cover mandatory clembench metric scores, so their calculation does not need to be
implemented anew for each new clemgame.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>episode_interactions</code></strong></dt>
<dd>Dict containing the episode's interactions. This contains the actions recorded during
a benchmark run.</dd>
</dl></div>
</dd>
<dt id="clemcore.clemgame.GameScorer.score_turns"><code class="name flex">
<span>def <span class="ident">score_turns</span></span>(<span>self, episode_interactions: Dict) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def score_turns(self, episode_interactions: Dict) -&gt; None:
    &#34;&#34;&#34;Iterate over episode turns, calculate and log turn-level scores.
    This method is intended to contain any game-specific turn-level scoring. Must be implemented!
    Use the log_turn_score method to log turn-level scores.
    Args:
        episode_interactions: Dict containing the episode&#39;s interactions. This contains the actions recorded during
            a benchmark run.
    &#34;&#34;&#34;
    # Loop over turns, calculate and log turn-specific scores
    raise NotImplementedError()</code></pre>
</details>
<div class="desc"><p>Iterate over episode turns, calculate and log turn-level scores.
This method is intended to contain any game-specific turn-level scoring. Must be implemented!
Use the log_turn_score method to log turn-level scores.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>episode_interactions</code></strong></dt>
<dd>Dict containing the episode's interactions. This contains the actions recorded during
a benchmark run.</dd>
</dl></div>
</dd>
<dt id="clemcore.clemgame.GameScorer.store_results_file"><code class="name flex">
<span>def <span class="ident">store_results_file</span></span>(<span>self,<br>data,<br>file_name: str,<br>dialogue_pair: str,<br>sub_dir: str = None,<br>results_dir: str = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def store_results_file(self, data, file_name: str, dialogue_pair: str,
                       sub_dir: str = None, results_dir: str = None):
    store_results_file(self.game_name, data, file_name,
                       dialogue_pair=dialogue_pair,
                       sub_dir=sub_dir,
                       results_dir=results_dir)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="clemcore.clemgame.GameScorer.store_scores"><code class="name flex">
<span>def <span class="ident">store_scores</span></span>(<span>self, results_root: str, dialogue_pair: str, game_record_dir: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def store_scores(self, results_root: str, dialogue_pair: str, game_record_dir: str):
    &#34;&#34;&#34;Store calculated scores to scores.json file.
    Args:
        results_root: The root path to the results directory.
        dialogue_pair: A string path to the Player pair results directory.
        game_record_dir: The game&#39;s record directory path.
    &#34;&#34;&#34;
    store_results_file(self.game_name, self.scores, &#34;scores.json&#34;,
                       dialogue_pair=dialogue_pair,
                       sub_dir=game_record_dir,
                       results_dir=results_root)</code></pre>
</details>
<div class="desc"><p>Store calculated scores to scores.json file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>results_root</code></strong></dt>
<dd>The root path to the results directory.</dd>
<dt><strong><code>dialogue_pair</code></strong></dt>
<dd>A string path to the Player pair results directory.</dd>
<dt><strong><code>game_record_dir</code></strong></dt>
<dd>The game's record directory path.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="clemcore.clemgame.GameSpec"><code class="flex name class">
<span>class <span class="ident">GameSpec</span></span>
<span>(</span><span>allow_underspecified: bool = False, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GameSpec(SimpleNamespace):
    &#34;&#34;&#34;Base class for game specifications.
    Holds all necessary information to play game in clembench (see README for list of attributes)
    &#34;&#34;&#34;

    def __init__(self, allow_underspecified: bool = False, **kwargs):
        super().__init__(**kwargs)
        # check for required fields
        if not allow_underspecified:
            if &#34;game_name&#34; not in self:
                raise KeyError(f&#34;No game name specified in entry {kwargs}&#34;)
            if &#34;game_path&#34; not in self:
                raise KeyError(f&#34;No game path specified in {kwargs}&#34;)
            if &#34;players&#34; not in self:
                raise KeyError(f&#34;No players specified in {kwargs}&#34;)

    def __repr__(self):
        &#34;&#34;&#34;Returns string representation of this GameSpec.&#34;&#34;&#34;
        return f&#34;GameSpec({str(self)})&#34;

    def __str__(self):
        &#34;&#34;&#34;Returns GameSpec instance attribute dict as string.&#34;&#34;&#34;
        return str(self.__dict__)

    def __getitem__(self, item):
        &#34;&#34;&#34;Access GameSpec instance attributes like dict items.
        Args:
            item: The string name of the instance attribute to get.
        Returns:
            The value of the GameSpec instance attribute, or if the instance does not have the attribute, the string
            passed as argument to this method.
        &#34;&#34;&#34;
        return getattr(self, item)

    def __contains__(self, attribute):
        &#34;&#34;&#34;Check GameSpec instance attributes like dict keys.
        Args:
            attribute: The string name of the instance attribute to check for.
        Returns:
            True if the GameSpec instance contains an attribute with the passed string name, False otherwise.
        &#34;&#34;&#34;
        return hasattr(self, attribute)

    def to_string(self):
        return json.dumps(self.__dict__, separators=(&#34;,&#34;, &#34;:&#34;), indent=None)

    def to_pretty_string(self):
        return json.dumps(self.__dict__, indent=2)

    @classmethod
    def from_name(cls, game_name: str):
        &#34;&#34;&#34;Create a GameSpec instance based on a game name.
        Args:
            game_name: The game name as string.
        &#34;&#34;&#34;
        assert game_name is not None
        return cls(game_name=game_name, allow_underspecified=True)

    @classmethod
    def from_string(cls, game_spec: str):
        &#34;&#34;&#34;Get a GameSpec instances for the passed string. This is rather intended to convert a game selector
        into a GameSpec. Hence, it must not be required to actually set a game_path or anything else.
        Takes both simple game names and (partially or fully specified) game specification data as JSON strings.
        Args:
            game_spec: A string to return a GameSpec instances for. Game name strings
                correspond to the &#39;game_name&#39; key value of a game in the game registry. May also be partially or fully
                specified game specification data as JSON strings.
        Returns:
            A GameSpec instance
        &#34;&#34;&#34;
        game_string = game_spec.replace(&#34;&#39;&#34;, &#34;\&#34;&#34;)  # make this a proper json
        try:
            game_dict = json.loads(game_string)
            return GameSpec.from_dict(game_dict, allow_underspecified=True)
        except Exception as e:  # likely not a json
            return GameSpec.from_name(game_string, allow_underspecified=True)

    @classmethod
    def from_directory(cls, dir_path: str) -&gt; List[&#34;GameSpec&#34;]:
        file_path = os.path.join(dir_path, &#34;clemgame.json&#34;)
        with open(file_path, encoding=&#39;utf-8&#39;) as f:
            game_spec = json.load(f)
        game_specs = []
        if isinstance(game_spec, dict):
            game_spec[&#34;game_path&#34;] = dir_path
            game_specs.append(cls.from_dict(game_spec))
        elif isinstance(game_spec, list):
            for _spec in game_spec:
                _spec[&#34;game_path&#34;] = dir_path
                game_specs.append(cls.from_dict(_spec))
        return game_specs

    @classmethod
    def from_dict(cls, spec: Dict, allow_underspecified: bool = False):
        &#34;&#34;&#34;Initialize a GameSpec from a dictionary.
        Can be used to directly create a GameSpec from a game registry entry.
        Args:
            spec: A game-specifying dict.
        Returns:
            A GameSpec instance with the data specified by the passed dict.
        &#34;&#34;&#34;
        return cls(allow_underspecified, **spec)

    def matches(self, spec: Dict):
        &#34;&#34;&#34;Check if the game features match a given specification.
        Args:
            spec: A game-specifying dict.
        Returns:
            True if the game features match the passed specification, False otherwise.
        Raises:
            KeyError: The GameSpec instance does not contain an attribute corresponding to a key in the passed
                game-specifying dict.
        &#34;&#34;&#34;
        for key, value in spec.items():
            if not self.__contains__(key):
                raise KeyError(f&#34;The specified key &#39;{key}&#39; for selecting games is not set in the game registry &#34;
                               f&#34;for game &#39;{self[&#39;game_name&#39;]}&#39;&#34;)
            if type(self[key]) == str:
                if not self[key] == value:
                    return False
            elif type(self[key]) == list:
                if value not in self[key]:
                    return False
        return True

    def get_game_file(self):
        &#34;&#34;&#34;Get the file path of the master.py of the game specified by this GameSpec instance.
        Main game file must be called master.py in game directory.
        Returns:
            The file path of the master.py of the game specified by this GameSpec instance as a string.
        &#34;&#34;&#34;
        return os.path.join(self.game_path, &#34;master.py&#34;)

    def game_file_exists(self):
        &#34;&#34;&#34;Check if master.py can be located at the specified game_path.
        Returns:
            True if the master.py is located at the specified game_path, False otherwise.
        &#34;&#34;&#34;
        return True if os.path.isfile(self.get_game_file()) else False

    def unify(self, other: &#34;GameSpec&#34;) -&gt; &#34;GameSpec&#34;:
        &#34;&#34;&#34;Unify two GameSpec instances.
        Args:
            other: The other GameSpec instance this instance is to be unified with.
        Returns:
            The GameSpec unification of this GameSpec instance and the passed GameSpec instance.
        Raises:
            ValueError: A ValueError exception is raised if the passed GameSpec instance does not unify with this
                GameSpec instance.
        &#34;&#34;&#34;
        result = nltk.featstruct.unify(self.__dict__, other.__dict__)
        if result is None:
            raise ValueError(f&#34;{self} does not unify with {other}&#34;)
        return GameSpec(**result)</code></pre>
</details>
<div class="desc"><p>Base class for game specifications.
Holds all necessary information to play game in clembench (see README for list of attributes)</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>types.SimpleNamespace</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="clemcore.clemgame.GameSpec.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>spec: Dict, allow_underspecified: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize a GameSpec from a dictionary.
Can be used to directly create a GameSpec from a game registry entry.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>spec</code></strong></dt>
<dd>A game-specifying dict.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A GameSpec instance with the data specified by the passed dict.</p></div>
</dd>
<dt id="clemcore.clemgame.GameSpec.from_directory"><code class="name flex">
<span>def <span class="ident">from_directory</span></span>(<span>dir_path: str) ‑> List[<a title="clemcore.clemgame.registry.GameSpec" href="registry.html#clemcore.clemgame.registry.GameSpec">GameSpec</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="clemcore.clemgame.GameSpec.from_name"><code class="name flex">
<span>def <span class="ident">from_name</span></span>(<span>game_name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a GameSpec instance based on a game name.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>game_name</code></strong></dt>
<dd>The game name as string.</dd>
</dl></div>
</dd>
<dt id="clemcore.clemgame.GameSpec.from_string"><code class="name flex">
<span>def <span class="ident">from_string</span></span>(<span>game_spec: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a GameSpec instances for the passed string. This is rather intended to convert a game selector
into a GameSpec. Hence, it must not be required to actually set a game_path or anything else.
Takes both simple game names and (partially or fully specified) game specification data as JSON strings.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>game_spec</code></strong></dt>
<dd>A string to return a GameSpec instances for. Game name strings
correspond to the 'game_name' key value of a game in the game registry. May also be partially or fully
specified game specification data as JSON strings.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A GameSpec instance</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="clemcore.clemgame.GameSpec.game_file_exists"><code class="name flex">
<span>def <span class="ident">game_file_exists</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def game_file_exists(self):
    &#34;&#34;&#34;Check if master.py can be located at the specified game_path.
    Returns:
        True if the master.py is located at the specified game_path, False otherwise.
    &#34;&#34;&#34;
    return True if os.path.isfile(self.get_game_file()) else False</code></pre>
</details>
<div class="desc"><p>Check if master.py can be located at the specified game_path.</p>
<h2 id="returns">Returns</h2>
<p>True if the master.py is located at the specified game_path, False otherwise.</p></div>
</dd>
<dt id="clemcore.clemgame.GameSpec.get_game_file"><code class="name flex">
<span>def <span class="ident">get_game_file</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_game_file(self):
    &#34;&#34;&#34;Get the file path of the master.py of the game specified by this GameSpec instance.
    Main game file must be called master.py in game directory.
    Returns:
        The file path of the master.py of the game specified by this GameSpec instance as a string.
    &#34;&#34;&#34;
    return os.path.join(self.game_path, &#34;master.py&#34;)</code></pre>
</details>
<div class="desc"><p>Get the file path of the master.py of the game specified by this GameSpec instance.
Main game file must be called master.py in game directory.</p>
<h2 id="returns">Returns</h2>
<p>The file path of the master.py of the game specified by this GameSpec instance as a string.</p></div>
</dd>
<dt id="clemcore.clemgame.GameSpec.matches"><code class="name flex">
<span>def <span class="ident">matches</span></span>(<span>self, spec: Dict)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def matches(self, spec: Dict):
    &#34;&#34;&#34;Check if the game features match a given specification.
    Args:
        spec: A game-specifying dict.
    Returns:
        True if the game features match the passed specification, False otherwise.
    Raises:
        KeyError: The GameSpec instance does not contain an attribute corresponding to a key in the passed
            game-specifying dict.
    &#34;&#34;&#34;
    for key, value in spec.items():
        if not self.__contains__(key):
            raise KeyError(f&#34;The specified key &#39;{key}&#39; for selecting games is not set in the game registry &#34;
                           f&#34;for game &#39;{self[&#39;game_name&#39;]}&#39;&#34;)
        if type(self[key]) == str:
            if not self[key] == value:
                return False
        elif type(self[key]) == list:
            if value not in self[key]:
                return False
    return True</code></pre>
</details>
<div class="desc"><p>Check if the game features match a given specification.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>spec</code></strong></dt>
<dd>A game-specifying dict.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if the game features match the passed specification, False otherwise.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>KeyError</code></dt>
<dd>The GameSpec instance does not contain an attribute corresponding to a key in the passed
game-specifying dict.</dd>
</dl></div>
</dd>
<dt id="clemcore.clemgame.GameSpec.to_pretty_string"><code class="name flex">
<span>def <span class="ident">to_pretty_string</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_pretty_string(self):
    return json.dumps(self.__dict__, indent=2)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="clemcore.clemgame.GameSpec.to_string"><code class="name flex">
<span>def <span class="ident">to_string</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_string(self):
    return json.dumps(self.__dict__, separators=(&#34;,&#34;, &#34;:&#34;), indent=None)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="clemcore.clemgame.GameSpec.unify"><code class="name flex">
<span>def <span class="ident">unify</span></span>(<span>self,<br>other: <a title="clemcore.clemgame.GameSpec" href="#clemcore.clemgame.GameSpec">GameSpec</a>) ‑> <a title="clemcore.clemgame.registry.GameSpec" href="registry.html#clemcore.clemgame.registry.GameSpec">GameSpec</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unify(self, other: &#34;GameSpec&#34;) -&gt; &#34;GameSpec&#34;:
    &#34;&#34;&#34;Unify two GameSpec instances.
    Args:
        other: The other GameSpec instance this instance is to be unified with.
    Returns:
        The GameSpec unification of this GameSpec instance and the passed GameSpec instance.
    Raises:
        ValueError: A ValueError exception is raised if the passed GameSpec instance does not unify with this
            GameSpec instance.
    &#34;&#34;&#34;
    result = nltk.featstruct.unify(self.__dict__, other.__dict__)
    if result is None:
        raise ValueError(f&#34;{self} does not unify with {other}&#34;)
    return GameSpec(**result)</code></pre>
</details>
<div class="desc"><p>Unify two GameSpec instances.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>other</code></strong></dt>
<dd>The other GameSpec instance this instance is to be unified with.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The GameSpec unification of this GameSpec instance and the passed GameSpec instance.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>A ValueError exception is raised if the passed GameSpec instance does not unify with this
GameSpec instance.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="clemcore.clemgame.Player"><code class="flex name class">
<span>class <span class="ident">Player</span></span>
<span>(</span><span>model: <a title="clemcore.backends.model_registry.Model" href="../backends/model_registry.html#clemcore.backends.model_registry.Model">Model</a>,<br>name: str = None,<br>game_recorder: <a title="clemcore.clemgame.recorder.GameRecorder" href="recorder.html#clemcore.clemgame.recorder.GameRecorder">GameRecorder</a> = None,<br>initial_prompt: str | Dict = None,<br>forget_extras: List[str] = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Player(abc.ABC):
    &#34;&#34;&#34;A participant of a game.

    A player can respond via a custom implementation, human input or a language model:

    - programmatic players are called via the _custom_response() method
    - human players are called via the _terminal_response() method
    - backend players are called via the generate_response() method of a backend
    &#34;&#34;&#34;
    def __init__(self, model: backends.Model, name: str = None, game_recorder: GameRecorder = None,
                 initial_prompt: Union[str, Dict] = None, forget_extras: List[str] = None):
        &#34;&#34;&#34;
        Args:
            model: The model used by this player.
            name: The player&#39;s name (optional). DialogueGameMaster assigns a name like &#34;Player 1 (Class)&#34;, overriding
                any name given here.
            game_recorder: The recorder for game interactions (optional). Default: NoopGameRecorder. DialogueGameMaster
                assigns its corresponding GameRecorder, overriding any given here.
            initial_prompt: The initial prompt given to the player (optional). Note that the initial prompt must be
                            set before the player is called the first time. If set, then on the first player call
                            the initial prompt will be added to the player&#39;s message history and logged as a
                            &#39;send message&#39; event without a response event. To properly log this make sure that a proper
                            game recorder is set. On each player call the initial prompt will be automatically merged
                            with the first memorized context given to the player (via two newlines) by the backend.
                            Alternatively, the initial prompt could be part of the first context given to the player.
            forget_extras: A list of context entries (keys) to forget after response generation.
                           This is useful to not keep image extras in the player&#39;s message history,
                           but still to prompt the model with an image given in the context.
        &#34;&#34;&#34;
        self._model: backends.Model = model
        self._name: str = name  # set by master
        self._game_recorder = game_recorder or NoopGameRecorder()  # set by master
        self._is_initial_call: bool = True
        self._initial_prompt: Dict = None if initial_prompt is None else self.__validate_initial_prompt(initial_prompt)
        self._forget_extras: List[str] = forget_extras or []  # set by game developer
        self._messages: List[Dict] = []  # internal state
        self._prompt = None  # internal state
        self._response_object = None  # internal state

    def __deepcopy__(self, memo):
        &#34;&#34;&#34;Deepcopy override method.
        Deepcopies Player class object, but keeps backend model and game recorder references intact.
        Args:
            memo: Dictionary of objects already copied during the current copying pass. (This is a deepcopy default.)
        &#34;&#34;&#34;
        _copy = type(self).__new__(self.__class__)
        memo[id(self)] = _copy
        for key, value in self.__dict__.items():
            if key not in [&#34;_model&#34;, &#34;_game_recorder&#34;]:
                setattr(_copy, key, deepcopy(value, memo))
        _copy._model = self._model
        return _copy

    @property
    def game_recorder(self):
        return self._game_recorder

    @game_recorder.setter
    def game_recorder(self, game_recorder: GameRecorder):
        self._game_recorder = game_recorder

    @property
    def initial_prompt(self):
        return self._initial_prompt

    @initial_prompt.setter
    def initial_prompt(self, prompt: Union[str, Dict]):
        if prompt is None:
            self._initial_prompt = None  # allow to unset the initial prompt (again)
            return
        self._initial_prompt = self.__validate_initial_prompt(prompt)

    def __validate_initial_prompt(self, prompt: Union[str, Dict]) -&gt; Dict:
        assert self._is_initial_call is True, &#34;The initial prompt can only be set before the first player call&#34;
        assert isinstance(prompt, (str, dict)), \
            f&#34;The initial prompt must be a str or dict, but is {type(prompt)}&#34;
        if isinstance(prompt, dict):
            assert &#34;role&#34; in prompt and prompt[&#34;role&#34;] == &#34;user&#34;, \
                &#34;The initial prompt requires a &#39;role&#39; entry with value &#39;user&#39;&#34;
            return deepcopy(prompt)
        return dict(role=&#34;user&#34;, content=prompt)  # by default assume str

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, name):
        self._name = name

    @property
    def model(self):
        return self._model

    def get_description(self) -&gt; str:
        &#34;&#34;&#34;Get a description string for this Player instance.
        Returns:
            A string describing the player&#39;s name given, class and model used.
        &#34;&#34;&#34;
        return f&#34;{self.name} ({self.__class__.__name__}): {self.model}&#34;

    def __log_send_context_event(self, content: str, label=None):
        &#34;&#34;&#34;Record a &#39;send message&#39; event with the current message content.&#34;&#34;&#34;
        assert self._game_recorder is not None, &#34;Cannot log player event, because game_recorder has not been set&#34;
        action = {&#39;type&#39;: &#39;send message&#39;, &#39;content&#39;: content, &#39;label&#39;: label}
        self._game_recorder.log_event(from_=&#39;GM&#39;, to=self.name, action=action)

    def __log_response_received_event(self, response, label=None):
        &#34;&#34;&#34;Record a &#39;get message&#39; event with the current response content.&#34;&#34;&#34;
        assert self._game_recorder is not None, &#34;Cannot log player event, because game_recorder has not been set&#34;
        action = {&#39;type&#39;: &#39;get message&#39;, &#39;content&#39;: response, &#39;label&#39;: label}
        _prompt, _response = self.get_last_call_info()  # log &#39;get message&#39; event including backend/API call
        self._game_recorder.log_event(from_=self.name, to=&#34;GM&#34;, action=action,
                                      call=(deepcopy(_prompt), deepcopy(_response)))

    def get_last_call_info(self):
        &#34;&#34;&#34;Get values of the last player call.
        Returns:
            Tuple of: Full prompt of the last call, full response of the last call.
        &#34;&#34;&#34;
        return self._prompt, self._response_object

    def __call__(self, context: Dict, memorize: bool = True) -&gt; str:
        &#34;&#34;&#34;
        Let the player respond (act verbally) to a given context.

        Args:
            context: The context to which the player should respond.
            memorize: Whether the context and response are to be added to the player&#39;s message history.
        Returns:
            The textual response.
        &#34;&#34;&#34;
        assert context[&#34;role&#34;] == &#34;user&#34;, f&#34;The context must be given by the user role, but is {context[&#39;role&#39;]}&#34;
        memorized_initial_prompt = None
        # handle initial/first call, with only the initial prompt user message in history:
        if self._is_initial_call and self._initial_prompt is not None:
            assert len(self._messages) == 0, (&#34;There must be no entry in the player&#39;s message history &#34;
                                              &#34;on the first call, when the initial prompt is set.&#34;)
            memorized_initial_prompt = deepcopy(self._initial_prompt)  # see explanation below
            self._messages.append(memorized_initial_prompt)  # merged with context in ensure_alternating_roles (backend)
            self.__log_send_context_event(memorized_initial_prompt[&#34;content&#34;], label=&#34;initial prompt&#34;)

        self.__log_send_context_event(context[&#34;content&#34;], label=&#34;context&#34; if memorize else &#34;forget&#34;)
        call_start = datetime.now()
        self._prompt, self._response_object, response_text = self.__call_model(context)
        # TODO: add default ContextExceededError handling here or below
        call_duration = datetime.now() - call_start
        self.__log_response_received_event(response_text, label=&#34;response&#34; if memorize else &#34;forget&#34;)

        self._response_object[&#34;clem_player&#34;] = {
            &#34;call_start&#34;: str(call_start),
            &#34;call_duration&#34;: str(call_duration),
            &#34;response&#34;: response_text,
            &#34;model_name&#34;: self.model.get_name()
        }

        # Copy context, so that original context given to the player is kept on forget extras. This is, for
        # example, necessary to collect the original contexts in the rollout buffer for playpen training.
        memorized_context = deepcopy(context)
        # forget must happen only after the model has been called with the extras
        # we forget extras here in any case, so that the prompt is also handled
        for extra in self._forget_extras:
            if extra in memorized_context:
                del memorized_context[extra]
            if memorized_initial_prompt is not None and extra in memorized_initial_prompt:
                del memorized_initial_prompt[extra]

        if memorize:
            self._messages.append(memorized_context)
            self._messages.append(dict(role=&#34;assistant&#34;, content=response_text))

        self._is_initial_call = False
        return response_text

    def __call_model(self, context: Dict):
        response_object = dict()
        prompt = context
        if isinstance(self.model, backends.CustomResponseModel):
            response_text = self._custom_response(context)
        elif isinstance(self.model, backends.HumanModel):
            response_text = self._terminal_response(context)
        else:
            prompt, response_object, response_text = self.model.generate_response(self._messages + [context])
            # TODO: add default ContextExceededError handling here or above
        return prompt, response_object, response_text

    def _terminal_response(self, context: Dict) -&gt; str:
        &#34;&#34;&#34;Response for human interaction via terminal.
        Overwrite this method to customize human inputs (model_name: human, terminal).
        Args:
            context: The dialogue context to which the player should respond.
        Returns:
            The human response as text.
        &#34;&#34;&#34;
        latest_response = &#34;Nothing has been said yet.&#34;
        if context is not None:
            latest_response = context[&#34;content&#34;]
        print(f&#34;\n{latest_response}&#34;)
        user_input = input(f&#34;Your response as {self.__class__.__name__}:\n&#34;)
        return user_input

    @abc.abstractmethod
    def _custom_response(self, context: Dict) -&gt; str:
        &#34;&#34;&#34;Response for programmatic Player interaction.

        Overwrite this method to implement programmatic behavior (model_name: mock, dry_run, programmatic, custom).
        Args:
            context: The dialogue context to which the player should respond.
        Returns:
            The programmatic response as text.
        &#34;&#34;&#34;
        pass</code></pre>
</details>
<div class="desc"><p>A participant of a game.</p>
<p>A player can respond via a custom implementation, human input or a language model:</p>
<ul>
<li>programmatic players are called via the _custom_response() method</li>
<li>human players are called via the _terminal_response() method</li>
<li>backend players are called via the generate_response() method of a backend</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>model</code></strong></dt>
<dd>The model used by this player.</dd>
<dt><strong><code>name</code></strong></dt>
<dd>The player's name (optional). DialogueGameMaster assigns a name like "Player 1 (Class)", overriding
any name given here.</dd>
<dt><strong><code>game_recorder</code></strong></dt>
<dd>The recorder for game interactions (optional). Default: NoopGameRecorder. DialogueGameMaster
assigns its corresponding GameRecorder, overriding any given here.</dd>
<dt><strong><code>initial_prompt</code></strong></dt>
<dd>The initial prompt given to the player (optional). Note that the initial prompt must be
set before the player is called the first time. If set, then on the first player call
the initial prompt will be added to the player's message history and logged as a
'send message' event without a response event. To properly log this make sure that a proper
game recorder is set. On each player call the initial prompt will be automatically merged
with the first memorized context given to the player (via two newlines) by the backend.
Alternatively, the initial prompt could be part of the first context given to the player.</dd>
<dt><strong><code>forget_extras</code></strong></dt>
<dd>A list of context entries (keys) to forget after response generation.
This is useful to not keep image extras in the player's message history,
but still to prompt the model with an image given in the context.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="clemcore.clemgame.Player.game_recorder"><code class="name">prop <span class="ident">game_recorder</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def game_recorder(self):
    return self._game_recorder</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="clemcore.clemgame.Player.initial_prompt"><code class="name">prop <span class="ident">initial_prompt</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def initial_prompt(self):
    return self._initial_prompt</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="clemcore.clemgame.Player.model"><code class="name">prop <span class="ident">model</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def model(self):
    return self._model</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="clemcore.clemgame.Player.name"><code class="name">prop <span class="ident">name</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self):
    return self._name</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="clemcore.clemgame.Player.get_description"><code class="name flex">
<span>def <span class="ident">get_description</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_description(self) -&gt; str:
    &#34;&#34;&#34;Get a description string for this Player instance.
    Returns:
        A string describing the player&#39;s name given, class and model used.
    &#34;&#34;&#34;
    return f&#34;{self.name} ({self.__class__.__name__}): {self.model}&#34;</code></pre>
</details>
<div class="desc"><p>Get a description string for this Player instance.</p>
<h2 id="returns">Returns</h2>
<p>A string describing the player's name given, class and model used.</p></div>
</dd>
<dt id="clemcore.clemgame.Player.get_last_call_info"><code class="name flex">
<span>def <span class="ident">get_last_call_info</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_last_call_info(self):
    &#34;&#34;&#34;Get values of the last player call.
    Returns:
        Tuple of: Full prompt of the last call, full response of the last call.
    &#34;&#34;&#34;
    return self._prompt, self._response_object</code></pre>
</details>
<div class="desc"><p>Get values of the last player call.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple of</code></dt>
<dd>Full prompt of the last call, full response of the last call.</dd>
</dl></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="clemcore" href="../index.html">clemcore</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="clemcore.clemgame.benchmark" href="benchmark.html">clemcore.clemgame.benchmark</a></code></li>
<li><code><a title="clemcore.clemgame.instances" href="instances.html">clemcore.clemgame.instances</a></code></li>
<li><code><a title="clemcore.clemgame.master" href="master.html">clemcore.clemgame.master</a></code></li>
<li><code><a title="clemcore.clemgame.metrics" href="metrics.html">clemcore.clemgame.metrics</a></code></li>
<li><code><a title="clemcore.clemgame.player" href="player.html">clemcore.clemgame.player</a></code></li>
<li><code><a title="clemcore.clemgame.recorder" href="recorder.html">clemcore.clemgame.recorder</a></code></li>
<li><code><a title="clemcore.clemgame.registry" href="registry.html">clemcore.clemgame.registry</a></code></li>
<li><code><a title="clemcore.clemgame.resources" href="resources.html">clemcore.clemgame.resources</a></code></li>
<li><code><a title="clemcore.clemgame.transcripts" href="transcripts/index.html">clemcore.clemgame.transcripts</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="clemcore.clemgame.DefaultGameRecorder" href="#clemcore.clemgame.DefaultGameRecorder">DefaultGameRecorder</a></code></h4>
<ul class="">
<li><code><a title="clemcore.clemgame.DefaultGameRecorder.interactions" href="#clemcore.clemgame.DefaultGameRecorder.interactions">interactions</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clemcore.clemgame.DialogueGameMaster" href="#clemcore.clemgame.DialogueGameMaster">DialogueGameMaster</a></code></h4>
<ul class="">
<li><code><a title="clemcore.clemgame.DialogueGameMaster.add_player" href="#clemcore.clemgame.DialogueGameMaster.add_player">add_player</a></code></li>
<li><code><a title="clemcore.clemgame.DialogueGameMaster.compute_episode_score" href="#clemcore.clemgame.DialogueGameMaster.compute_episode_score">compute_episode_score</a></code></li>
<li><code><a title="clemcore.clemgame.DialogueGameMaster.compute_response_score" href="#clemcore.clemgame.DialogueGameMaster.compute_response_score">compute_response_score</a></code></li>
<li><code><a title="clemcore.clemgame.DialogueGameMaster.get_context_for" href="#clemcore.clemgame.DialogueGameMaster.get_context_for">get_context_for</a></code></li>
<li><code><a title="clemcore.clemgame.DialogueGameMaster.get_current_player" href="#clemcore.clemgame.DialogueGameMaster.get_current_player">get_current_player</a></code></li>
<li><code><a title="clemcore.clemgame.DialogueGameMaster.get_game_state" href="#clemcore.clemgame.DialogueGameMaster.get_game_state">get_game_state</a></code></li>
<li><code><a title="clemcore.clemgame.DialogueGameMaster.get_players" href="#clemcore.clemgame.DialogueGameMaster.get_players">get_players</a></code></li>
<li><code><a title="clemcore.clemgame.DialogueGameMaster.get_response_feedback" href="#clemcore.clemgame.DialogueGameMaster.get_response_feedback">get_response_feedback</a></code></li>
<li><code><a title="clemcore.clemgame.DialogueGameMaster.play" href="#clemcore.clemgame.DialogueGameMaster.play">play</a></code></li>
<li><code><a title="clemcore.clemgame.DialogueGameMaster.set_context_for" href="#clemcore.clemgame.DialogueGameMaster.set_context_for">set_context_for</a></code></li>
<li><code><a title="clemcore.clemgame.DialogueGameMaster.setup" href="#clemcore.clemgame.DialogueGameMaster.setup">setup</a></code></li>
<li><code><a title="clemcore.clemgame.DialogueGameMaster.step" href="#clemcore.clemgame.DialogueGameMaster.step">step</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clemcore.clemgame.GameBenchmark" href="#clemcore.clemgame.GameBenchmark">GameBenchmark</a></code></h4>
<ul class="">
<li><code><a title="clemcore.clemgame.GameBenchmark.compute_scores" href="#clemcore.clemgame.GameBenchmark.compute_scores">compute_scores</a></code></li>
<li><code><a title="clemcore.clemgame.GameBenchmark.create_game_instance_iterator" href="#clemcore.clemgame.GameBenchmark.create_game_instance_iterator">create_game_instance_iterator</a></code></li>
<li><code><a title="clemcore.clemgame.GameBenchmark.create_game_master" href="#clemcore.clemgame.GameBenchmark.create_game_master">create_game_master</a></code></li>
<li><code><a title="clemcore.clemgame.GameBenchmark.create_game_scorer" href="#clemcore.clemgame.GameBenchmark.create_game_scorer">create_game_scorer</a></code></li>
<li><code><a title="clemcore.clemgame.GameBenchmark.get_dialogue_pair_descriptor" href="#clemcore.clemgame.GameBenchmark.get_dialogue_pair_descriptor">get_dialogue_pair_descriptor</a></code></li>
<li><code><a title="clemcore.clemgame.GameBenchmark.run" href="#clemcore.clemgame.GameBenchmark.run">run</a></code></li>
<li><code><a title="clemcore.clemgame.GameBenchmark.setup" href="#clemcore.clemgame.GameBenchmark.setup">setup</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clemcore.clemgame.GameInstanceGenerator" href="#clemcore.clemgame.GameInstanceGenerator">GameInstanceGenerator</a></code></h4>
<ul class="">
<li><code><a title="clemcore.clemgame.GameInstanceGenerator.add_experiment" href="#clemcore.clemgame.GameInstanceGenerator.add_experiment">add_experiment</a></code></li>
<li><code><a title="clemcore.clemgame.GameInstanceGenerator.add_game_instance" href="#clemcore.clemgame.GameInstanceGenerator.add_game_instance">add_game_instance</a></code></li>
<li><code><a title="clemcore.clemgame.GameInstanceGenerator.generate" href="#clemcore.clemgame.GameInstanceGenerator.generate">generate</a></code></li>
<li><code><a title="clemcore.clemgame.GameInstanceGenerator.on_generate" href="#clemcore.clemgame.GameInstanceGenerator.on_generate">on_generate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clemcore.clemgame.GameInstanceIterator" href="#clemcore.clemgame.GameInstanceIterator">GameInstanceIterator</a></code></h4>
<ul class="">
<li><code><a title="clemcore.clemgame.GameInstanceIterator.clone" href="#clemcore.clemgame.GameInstanceIterator.clone">clone</a></code></li>
<li><code><a title="clemcore.clemgame.GameInstanceIterator.reset" href="#clemcore.clemgame.GameInstanceIterator.reset">reset</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clemcore.clemgame.GameMaster" href="#clemcore.clemgame.GameMaster">GameMaster</a></code></h4>
<ul class="two-column">
<li><code><a title="clemcore.clemgame.GameMaster.game_recorder" href="#clemcore.clemgame.GameMaster.game_recorder">game_recorder</a></code></li>
<li><code><a title="clemcore.clemgame.GameMaster.load_json" href="#clemcore.clemgame.GameMaster.load_json">load_json</a></code></li>
<li><code><a title="clemcore.clemgame.GameMaster.load_template" href="#clemcore.clemgame.GameMaster.load_template">load_template</a></code></li>
<li><code><a title="clemcore.clemgame.GameMaster.log_event" href="#clemcore.clemgame.GameMaster.log_event">log_event</a></code></li>
<li><code><a title="clemcore.clemgame.GameMaster.log_key" href="#clemcore.clemgame.GameMaster.log_key">log_key</a></code></li>
<li><code><a title="clemcore.clemgame.GameMaster.log_next_round" href="#clemcore.clemgame.GameMaster.log_next_round">log_next_round</a></code></li>
<li><code><a title="clemcore.clemgame.GameMaster.log_players" href="#clemcore.clemgame.GameMaster.log_players">log_players</a></code></li>
<li><code><a title="clemcore.clemgame.GameMaster.log_to_self" href="#clemcore.clemgame.GameMaster.log_to_self">log_to_self</a></code></li>
<li><code><a title="clemcore.clemgame.GameMaster.play" href="#clemcore.clemgame.GameMaster.play">play</a></code></li>
<li><code><a title="clemcore.clemgame.GameMaster.setup" href="#clemcore.clemgame.GameMaster.setup">setup</a></code></li>
<li><code><a title="clemcore.clemgame.GameMaster.store_records" href="#clemcore.clemgame.GameMaster.store_records">store_records</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clemcore.clemgame.GameRecorder" href="#clemcore.clemgame.GameRecorder">GameRecorder</a></code></h4>
<ul class="">
<li><code><a title="clemcore.clemgame.GameRecorder.log_event" href="#clemcore.clemgame.GameRecorder.log_event">log_event</a></code></li>
<li><code><a title="clemcore.clemgame.GameRecorder.log_key" href="#clemcore.clemgame.GameRecorder.log_key">log_key</a></code></li>
<li><code><a title="clemcore.clemgame.GameRecorder.log_next_round" href="#clemcore.clemgame.GameRecorder.log_next_round">log_next_round</a></code></li>
<li><code><a title="clemcore.clemgame.GameRecorder.log_players" href="#clemcore.clemgame.GameRecorder.log_players">log_players</a></code></li>
<li><code><a title="clemcore.clemgame.GameRecorder.store_records" href="#clemcore.clemgame.GameRecorder.store_records">store_records</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clemcore.clemgame.GameRegistry" href="#clemcore.clemgame.GameRegistry">GameRegistry</a></code></h4>
<ul class="">
<li><code><a title="clemcore.clemgame.GameRegistry.from_directories_and_cwd_files" href="#clemcore.clemgame.GameRegistry.from_directories_and_cwd_files">from_directories_and_cwd_files</a></code></li>
<li><code><a title="clemcore.clemgame.GameRegistry.get_game_specs" href="#clemcore.clemgame.GameRegistry.get_game_specs">get_game_specs</a></code></li>
<li><code><a title="clemcore.clemgame.GameRegistry.get_game_specs_that_unify_with" href="#clemcore.clemgame.GameRegistry.get_game_specs_that_unify_with">get_game_specs_that_unify_with</a></code></li>
<li><code><a title="clemcore.clemgame.GameRegistry.register_from_directories" href="#clemcore.clemgame.GameRegistry.register_from_directories">register_from_directories</a></code></li>
<li><code><a title="clemcore.clemgame.GameRegistry.register_from_list" href="#clemcore.clemgame.GameRegistry.register_from_list">register_from_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clemcore.clemgame.GameResourceLocator" href="#clemcore.clemgame.GameResourceLocator">GameResourceLocator</a></code></h4>
<ul class="two-column">
<li><code><a title="clemcore.clemgame.GameResourceLocator.load_csv" href="#clemcore.clemgame.GameResourceLocator.load_csv">load_csv</a></code></li>
<li><code><a title="clemcore.clemgame.GameResourceLocator.load_file" href="#clemcore.clemgame.GameResourceLocator.load_file">load_file</a></code></li>
<li><code><a title="clemcore.clemgame.GameResourceLocator.load_instances" href="#clemcore.clemgame.GameResourceLocator.load_instances">load_instances</a></code></li>
<li><code><a title="clemcore.clemgame.GameResourceLocator.load_json" href="#clemcore.clemgame.GameResourceLocator.load_json">load_json</a></code></li>
<li><code><a title="clemcore.clemgame.GameResourceLocator.load_results_json" href="#clemcore.clemgame.GameResourceLocator.load_results_json">load_results_json</a></code></li>
<li><code><a title="clemcore.clemgame.GameResourceLocator.load_template" href="#clemcore.clemgame.GameResourceLocator.load_template">load_template</a></code></li>
<li><code><a title="clemcore.clemgame.GameResourceLocator.store_file" href="#clemcore.clemgame.GameResourceLocator.store_file">store_file</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clemcore.clemgame.GameScorer" href="#clemcore.clemgame.GameScorer">GameScorer</a></code></h4>
<ul class="two-column">
<li><code><a title="clemcore.clemgame.GameScorer.compute_scores" href="#clemcore.clemgame.GameScorer.compute_scores">compute_scores</a></code></li>
<li><code><a title="clemcore.clemgame.GameScorer.game_instance" href="#clemcore.clemgame.GameScorer.game_instance">game_instance</a></code></li>
<li><code><a title="clemcore.clemgame.GameScorer.log_episode_score" href="#clemcore.clemgame.GameScorer.log_episode_score">log_episode_score</a></code></li>
<li><code><a title="clemcore.clemgame.GameScorer.log_main_score" href="#clemcore.clemgame.GameScorer.log_main_score">log_main_score</a></code></li>
<li><code><a title="clemcore.clemgame.GameScorer.log_turn_score" href="#clemcore.clemgame.GameScorer.log_turn_score">log_turn_score</a></code></li>
<li><code><a title="clemcore.clemgame.GameScorer.score_game" href="#clemcore.clemgame.GameScorer.score_game">score_game</a></code></li>
<li><code><a title="clemcore.clemgame.GameScorer.score_game_end" href="#clemcore.clemgame.GameScorer.score_game_end">score_game_end</a></code></li>
<li><code><a title="clemcore.clemgame.GameScorer.score_requests" href="#clemcore.clemgame.GameScorer.score_requests">score_requests</a></code></li>
<li><code><a title="clemcore.clemgame.GameScorer.score_turns" href="#clemcore.clemgame.GameScorer.score_turns">score_turns</a></code></li>
<li><code><a title="clemcore.clemgame.GameScorer.store_results_file" href="#clemcore.clemgame.GameScorer.store_results_file">store_results_file</a></code></li>
<li><code><a title="clemcore.clemgame.GameScorer.store_scores" href="#clemcore.clemgame.GameScorer.store_scores">store_scores</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clemcore.clemgame.GameSpec" href="#clemcore.clemgame.GameSpec">GameSpec</a></code></h4>
<ul class="two-column">
<li><code><a title="clemcore.clemgame.GameSpec.from_dict" href="#clemcore.clemgame.GameSpec.from_dict">from_dict</a></code></li>
<li><code><a title="clemcore.clemgame.GameSpec.from_directory" href="#clemcore.clemgame.GameSpec.from_directory">from_directory</a></code></li>
<li><code><a title="clemcore.clemgame.GameSpec.from_name" href="#clemcore.clemgame.GameSpec.from_name">from_name</a></code></li>
<li><code><a title="clemcore.clemgame.GameSpec.from_string" href="#clemcore.clemgame.GameSpec.from_string">from_string</a></code></li>
<li><code><a title="clemcore.clemgame.GameSpec.game_file_exists" href="#clemcore.clemgame.GameSpec.game_file_exists">game_file_exists</a></code></li>
<li><code><a title="clemcore.clemgame.GameSpec.get_game_file" href="#clemcore.clemgame.GameSpec.get_game_file">get_game_file</a></code></li>
<li><code><a title="clemcore.clemgame.GameSpec.matches" href="#clemcore.clemgame.GameSpec.matches">matches</a></code></li>
<li><code><a title="clemcore.clemgame.GameSpec.to_pretty_string" href="#clemcore.clemgame.GameSpec.to_pretty_string">to_pretty_string</a></code></li>
<li><code><a title="clemcore.clemgame.GameSpec.to_string" href="#clemcore.clemgame.GameSpec.to_string">to_string</a></code></li>
<li><code><a title="clemcore.clemgame.GameSpec.unify" href="#clemcore.clemgame.GameSpec.unify">unify</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="clemcore.clemgame.Player" href="#clemcore.clemgame.Player">Player</a></code></h4>
<ul class="two-column">
<li><code><a title="clemcore.clemgame.Player.game_recorder" href="#clemcore.clemgame.Player.game_recorder">game_recorder</a></code></li>
<li><code><a title="clemcore.clemgame.Player.get_description" href="#clemcore.clemgame.Player.get_description">get_description</a></code></li>
<li><code><a title="clemcore.clemgame.Player.get_last_call_info" href="#clemcore.clemgame.Player.get_last_call_info">get_last_call_info</a></code></li>
<li><code><a title="clemcore.clemgame.Player.initial_prompt" href="#clemcore.clemgame.Player.initial_prompt">initial_prompt</a></code></li>
<li><code><a title="clemcore.clemgame.Player.model" href="#clemcore.clemgame.Player.model">model</a></code></li>
<li><code><a title="clemcore.clemgame.Player.name" href="#clemcore.clemgame.Player.name">name</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
