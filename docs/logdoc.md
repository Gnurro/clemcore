# Keeping Records of Interactions
When a clemgame is run, the `GameMaster` class (and the `DialogueGameMaster` class inheriting from it) produces a record 
of interactions. This record is stored as a JSON file named `interactions.json` in a `records/<model>/<gamename>` 
subdirectory corresponding to the experiment and episode. For example, the interactions recorded for the openchat-3.5 
model as both players of the `taboo` clemgame experiment `0_high_en` `episode_0` (corresponding to the first instance of 
this experiment) are stored in `records/openchat_3.5-t0.0--openchat_3.5-t0.0/taboo/0_high_en/episode_0/`.

The game master should log every action that is necessary to score the game,
generate the dialogue transcripts and other relevant information for 
posterior inspection of the interaction.

The game master should record every interaction that is necessary to score the game, generate the dialogue transcripts 
and other relevant information for posterior inspection of the interactions.

This is taken care of by the `GameRecorder` class, which has methods to log various types of information:

- ```log_players```: must be called once, in the game setup, to log the description of the agents playing each role in 
the game.
- ```log_event```: must be called to log every action; see details below.
- ```log_next_turn```: must be called at the beginning of every game turn; what a turn means is a decision of the game 
designer.
- ```log_key```: can be optionally used to log game-specific keys and values.

The `GameMaster` class inherits these methods from `GameRecorder`.

The `DialogueGameMaster` class inherits these methods from `GameMaster`, and has additional logging methods:

- `log_message_to`: Logs a GM->Player `send_message` action.
- `log_message_to_self`: Logs a GM->GM `metadata` action.
- `log_to_self`: Logs a GM->GM action of a type passed as `type_` argument. This method is useful to record both 
standard and custom scoring-relevant actions.

## Logging Players
The GameMaster ```setup``` method must call ```log_player``` passing a dictionary that maps player identifier strings to 
a description of the player (e.g. is it a pretrained model, a human, or a program).

Use ```GM``` for the GameMaster and ```Player i```, where i is an integer, for the other players. These identifiers for 
players are also used in the ```interaction``` dictionaries.

## Logging Interaction
An interaction is a list of lists, in chronological order, of the actions made by the
game master. Such actions should be logged by the GameMaster using the 
```log_event``` method which also logs the timestamp. 

The interactions record for an episode is a dictionary containing at least the `players` and `turns` keys.

The `players` key contains a dictionary with the identifiers described in [Logging Players](logging-players).

The `turns` key contains a list of lists, of the actions logged by the game master, in chronological order. The 
`log_event` method is to be used to log these actions, automatically adding timestamps to actions. 

??? An event can be only an action or an action and a corresponding API call (in which case they are both identifiable by 
the shared timestamp).

```log_event``` requires a ```from``` and a ```to``` value (both are Player identifiers, see 
[Logging Players](##logging_players).) It also requires an action dictionary that must contain at least the two 
following keys:

- ```type```: the action type (see basic types below)
- ```content```: a string with the action message.

The basic action types are:

- ```send message```: an utterance that is sent from GM to a player (its content is only the last utterance, not the whole dialogue context)
- ```get messsage```: an utterance generated by a player
- ```metadata```: any relevant information the GameMaster logs (not visible to players, but that should be in the transcript)
- ```parse```: a manipulation of a response string, when needed (e.g. to extract a grid from a response)
- ```error```: an error message emited by the GameMaster
- ```invalid format```: an invalid answer that causes the game to be aborted

If a game needs more custom actions, they should be documented in the game directory. See [Custom Actions](custom-actions).

Use `from: "GM"` and `to: "GM"` for messages that the Game Master emits to itself (not the players).
The `DialogueGameMaster` methods `log_message_to_self` and `log_to_self` call `log_event` with `from: "GM"` and 
`to: "GM"`.

Here is an example of what the `interactions.json` file of an episode will look like:

```json
{
  "some_other_key_1": "some_other_value",
  "some_other_key_2": "some_other_value",
  "players": {
    "GM": "Game Master for privateshared",
    "Player 1": "gpt-3.5",
    "Player 2": "human"
  },
  "turns": [
    [
      {
        "timestamp": "timestamp_1",
        "from": "GM",
        "to": "Player 1",
        "action": {
          "type": "send message",
          "content": "this is a message from GM to Player 1."
        }
      },
      {
        "timestamp": "timestamp_2",
        "from": "Player 1",
        "to": "GM",
        "action": {
          "type": "get message",
          "content": "this is a message from Player 1 to GM."
        }
      },
      {
        "timestamp": "timestamp_3",
        "from": "GM",
        "to": "GM",
        "action": {
          "type": "parse",
          "content": "this is a parsed response from GM to GM.",
          "other_key": "other_value"
        }
      }
    ],
    [
      {
        "timestamp": "timestamp_4",
        "from": "GM",
        "to": "GM",
        "action": {
          "type": "metadata",
          "content": "metadata not visible to players but added to transcript"
        }
      },
      {
        "timestamp": "timestamp_5",
        "from": "GM",
        "to": "Player 2",
        "action": {
          "type": "send message",
          "content": "this is a message from GM to Player 2."
        }
      },
      {
        "timestamp": "timestamp_6",
        "from": "Player 2",
        "to": "GM",
        "action": {
          "type": "get message",
          "content": "this is a message from Player 2 to GM."
        }
      }
    ]
  ]
}
```

## Logging Calls
We also want to log the exact input and output from an API, because sometimes 
the GameMaster's prompt needs to be manipulated differently for each type of API.

We also want to log the exact input and output from an API, to make sure that there are no issues with model outputs and 
their processing by backends and the game master.

The API call returns the manipulated prompt and the raw response, that should
just simple be logged by the GameMaster without further interference.

The backend/API call returns the manipulated prompt and the raw response, which should simply be logged by the 
game master without any modifications. (? The `DialogueGameMaster` class does this automatically.)

For that, use the optional ```call``` argument in ```log_event``` to log the call with the same timestamp and an action.

The calls will be stored in a ```requests.json``` that contains the raw inputs and outputs of calls made to APIs.

Here is an example of how a basic requests file of an episode will look like:

```json
[
    {
        "timestamp": "timestamp_1",
        "manipulated_prompt_obj": "the whole prompt object passed to the API call",
        "raw_response_obj": "the whole response object received from the API call"
    },
    {
        "timestamp": "timestamp_2",
        "manipulated_prompt_obj": "the whole prompt object passed to the API call",
        "raw_response_obj": "the whole response object received from the API call"
    }
]
```

Depending on the backend/API `raw_response_obj` is likely to be more extensive.

## Logging Scores

Scores are evaluated using the `GameScorer` class, or preferably a game-specific child class of it. Game-specific child 
classes of `GameScorer` allow for the implementation of custom scores.

`GameScorer` iterates over `turns` in an episode's `interactions.json` and assigns scores based on the recorded actions 
in each turn.

- `log_turn_score`: should be called in the scoring method to log turn-level scores.
- `log_episode_score`: should be called in the scoring method to log episode-level scores.

Games can have multiple turn-level scores and episode-level scores.

Use `log_turn_score` to log a score name and its value for a given turn index and `log_episode_score` to log a score 
name and its value for the whole episode. Episode scores are usually measures of game success.

The score results will be stored to `scores.json` which contains:
- `turn scores`: the turn-level scores for each game turn.
- `episode scores`: the episode-level scores for the episode.

You can log as many scores as you wish. The minimal requirements is to log the episode-level scores defined in 
`clemgame/metrics.py` (see the paper's appendix for details).

**Important**: If the game was aborted, all episode-level scores should be `np.nan` and turn-level scores can be logged 
up to the turn when the game was aborted. If the game was won or lost, all metrics should be a numerical value. This is 
specially revelant for the main score of each game, so that the evaluation script correctly distinguishes %played and 
computes the main score only for actually played games.  

Here is an example of how the `scores.json` file of an episode will look like:

```json
{
    "turn scores": {
        "1": {"accuracy": 0.8, "f1": 0.7},
        "2": {"accuracy": 0.5, "f1": 0.8},
        "3": {"accuracy": 0.4, "f1": 0.9}
    },
    "episode scores": {
        "accuracy": 0.8,
        "f1": 0.7
    }
}
```

### IMPORTANT: Inspecting the game records
During development, always check the generated `interactions.json` and `requests.json` to make sure that the API calls 
are passing the correct structure and that the records are being correctly saved.

`interactions.json` is built by the game master as a way to represent the actual interaction (with all its meta-events 
like parsing messages or checking game rules). This is used to create the transcripts, which are a user-friendly 
visualisation of the interaction. But remember that this does not reflect the actual API calls, this only reflects what 
the game master makes of the game!

The actual prompts and responses from the model are saved into `requests.json`, when an action is logged with its 
corresponding prompt and response object (see below how to do it). This file will reflect what was actually passed to 
and from the LLM. Remember that LLMS do not keep a internal state, so every call to a model must contain its full 
dialogue history. Also remember that when there are two LLMs playing at once, each will have its own dialogue history, 
which may be different! That's why, for debugging purposes, only looking at `interactions.json` is not enough, because 
it may not reflect exactly what the LLMs consumed and output.
